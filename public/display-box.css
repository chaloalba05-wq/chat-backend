/* ===== CHAT SCRIPT WITH MOBILE SCROLLING FIXES ===== */

// ===== GLOBAL VARIABLES =====
const socket = io("https://chat-backend-p2b9.onrender.com", {
  reconnection: true,
  reconnectionAttempts: Infinity,
  reconnectionDelay: 1000,
  reconnectionDelayMax: 5000,
  timeout: 20000,
  transports: ['websocket', 'polling'],
  query: {
    clientType: 'agent',
    version: '2.0'
  }
});

let currentUserId = "";
let selectedFile = null;
let isScrolledToBottom = true;
let messages = {};
let activeChatUser = null;
let userTypingTimeout = null;

// ===== MOBILE SCROLLING FIXES (MINIMAL ADDITIONS) =====
function initScrolling() {
  const messagesContainer = document.querySelector('.messages-container');
  if (!messagesContainer) return;
  
  // Add scroll listener
  messagesContainer.addEventListener('scroll', function() {
    const scrollTop = this.scrollTop;
    const scrollHeight = this.scrollHeight;
    const clientHeight = this.clientHeight;
    const scrollBottom = scrollHeight - scrollTop - clientHeight;
    
    isScrolledToBottom = scrollBottom < 50;
    
    // Show/hide scroll button
    const scrollBtn = document.querySelector('.scroll-bottom-btn');
    if (scrollBtn) {
      if (scrollBottom > 100) {
        scrollBtn.classList.add('visible');
      } else {
        scrollBtn.classList.remove('visible');
      }
    }
  }, { passive: true });
  
  // Scroll to bottom button
  const scrollBtn = document.querySelector('.scroll-bottom-btn');
  if (scrollBtn) {
    scrollBtn.addEventListener('click', scrollToBottom);
  }
}

function scrollToBottom() {
  const container = document.querySelector('.messages-container');
  if (!container) return;
  
  container.scrollTop = container.scrollHeight;
  isScrolledToBottom = true;
  
  const scrollBtn = document.querySelector('.scroll-bottom-btn');
  if (scrollBtn) {
    scrollBtn.classList.remove('visible');
  }
}

function scrollToBottomSmooth() {
  const container = document.querySelector('.messages-container');
  if (!container) return;
  
  if (isScrolledToBottom) {
    container.scrollTo({
      top: container.scrollHeight,
      behavior: 'smooth'
    });
  }
}

// ===== LOCAL STORAGE UTILITIES =====
const Storage = {
  prefix: 'chat_agent_',
  
  save(key, data) {
    try {
      localStorage.setItem(this.prefix + key, JSON.stringify(data));
    } catch (error) {
      console.error('Storage error:', error);
    }
  },
  
  load(key) {
    try {
      const data = localStorage.getItem(this.prefix + key);
      return data ? JSON.parse(data) : null;
    } catch (error) {
      console.error('Storage error:', error);
      return null;
    }
  },
  
  clear(key) {
    localStorage.removeItem(this.prefix + key);
  },
  
  saveMessages(userId, messages) {
    this.save(`messages_${userId}`, {
      messages: messages,
      timestamp: Date.now()
    });
  },
  
  loadMessages(userId) {
    const data = this.load(`messages_${userId}`);
    return data ? data.messages : [];
  }
};

// ===== PERSISTENT CONNECTION MANAGER =====
const ConnectionManager = {
  status: 'disconnected',
  reconnectAttempts: 0,
  maxReconnectAttempts: 20,
  
  init() {
    this.setupEventListeners();
  },
  
  setupEventListeners() {
    window.addEventListener('online', () => {
      console.log('üåê Online - reconnecting...');
      this.reconnect();
    });
    
    window.addEventListener('offline', () => {
      console.log('üåê Offline');
      this.showStatus('disconnected', 'Offline - Will reconnect automatically');
    });
    
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible' && !socket.connected) {
        console.log('üëÄ Page visible - reconnecting...');
        this.reconnect();
      }
    });
  },
  
  reconnect() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.log('üõë Max reconnection attempts reached');
      return;
    }
    
    this.reconnectAttempts++;
    console.log(`üîÑ Reconnection attempt ${this.reconnectAttempts}`);
    
    socket.connect();
  },
  
  showStatus(status, message) {
    this.status = status;
    
    const indicator = document.getElementById('connectionStatusIndicator');
    if (indicator) {
      indicator.className = `connection-status-indicator ${status}`;
      indicator.textContent = message;
      indicator.style.display = 'block';
      
      if (status === 'connected') {
        setTimeout(() => {
          indicator.style.display = 'none';
        }, 3000);
      }
    }
  },
  
  reset() {
    this.reconnectAttempts = 0;
    this.status = 'connected';
  }
};

// ===== SEND CONTROLLER =====
const SendController = {
  isSending: false,
  lastSendTime: 0,
  
  canSend() {
    const now = Date.now();
    
    if (this.isSending) {
      return { canSend: false, reason: 'Already sending' };
    }
    
    if (now - this.lastSendTime < 500) {
      return { canSend: false, reason: 'Too fast' };
    }
    
    return { canSend: true };
  },
  
  beginSend() {
    this.isSending = true;
    this.lastSendTime = Date.now();
  },
  
  finishSend() {
    this.isSending = false;
  }
};

// ===== FORMATTING FUNCTIONS =====
function formatTime(timestamp) {
  const date = new Date(timestamp);
  return date.toLocaleTimeString([], { 
    hour: '2-digit', 
    minute: '2-digit',
    hour12: true 
  });
}

function formatDate(timestamp) {
  const date = new Date(timestamp);
  const today = new Date();
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);
  
  if (date.toDateString() === today.toDateString()) {
    return 'Today';
  } else if (date.toDateString() === yesterday.toDateString()) {
    return 'Yesterday';
  } else {
    return date.toLocaleDateString([], { 
      month: 'short', 
      day: 'numeric' 
    });
  }
}

function formatFileSize(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

// ===== UI MANAGEMENT =====
function showChatDetail(user) {
  activeChatUser = user;
  currentUserId = user.id;
  
  // Update chat detail header
  const userAvatar = document.querySelector('.chat-detail-user-avatar');
  const userName = document.querySelector('.chat-detail-user-name');
  const userNumber = document.querySelector('.chat-detail-user-number');
  
  if (userAvatar) {
    userAvatar.textContent = user.name.charAt(0).toUpperCase();
  }
  
  if (userName) {
    userName.textContent = user.name;
  }
  
  if (userNumber) {
    userNumber.textContent = user.id;
  }
  
  // Show chat detail view
  const chatDetail = document.querySelector('.chat-detail-view');
  if (chatDetail) {
    chatDetail.classList.add('active');
    document.body.style.overflow = 'hidden';
  }
  
  // Load messages
  loadMessagesForUser(user.id);
  
  // Focus on input
  setTimeout(() => {
    const input = document.querySelector('.message-input');
    if (input) input.focus();
  }, 200);
  
  // Initialize scrolling
  setTimeout(initScrolling, 100);
  setTimeout(scrollToBottom, 150);
}

function hideChatDetail() {
  const chatDetail = document.querySelector('.chat-detail-view');
  if (chatDetail) {
    chatDetail.classList.remove('active');
    document.body.style.overflow = '';
  }
  
  activeChatUser = null;
  currentUserId = "";
  
  // Save current messages before leaving
  if (currentUserId) {
    Storage.saveMessages(currentUserId, messages[currentUserId] || []);
  }
}

function updateUserList(users) {
  const userList = document.querySelector('.user-list');
  if (!userList) return;
  
  // Clear existing users (except title)
  const userItems = userList.querySelectorAll('.user-item');
  userItems.forEach(item => item.remove());
  
  if (users.length === 0) {
    const emptyState = document.createElement('div');
    emptyState.className = 'empty-state';
    emptyState.innerHTML = `
      <div class="empty-state-icon">üí¨</div>
      <div class="empty-state-title">No active chats</div>
      <div class="empty-state-subtitle">Users will appear here when they start chatting</div>
    `;
    userList.appendChild(emptyState);
    return;
  }
  
  // Add users
  users.forEach(user => {
    const userItem = createUserItem(user);
    userList.appendChild(userItem);
  });
}

function createUserItem(user) {
  const div = document.createElement('div');
  div.className = 'user-item';
  if (user.id === currentUserId) {
    div.classList.add('active');
  }
  
  div.innerHTML = `
    <div class="user-avatar">${user.name.charAt(0).toUpperCase()}</div>
    <div class="user-content">
      <div class="user-name-row">
        <div class="user-name">${user.name}</div>
        <div class="user-time">${formatTime(user.lastActivity)}</div>
      </div>
      <div class="user-preview">${user.lastMessage || 'No messages yet'}</div>
    </div>
  `;
  
  div.addEventListener('click', () => showChatDetail(user));
  
  return div;
}

function createMessageElement(msg) {
  const wrapper = document.createElement('div');
  wrapper.className = 'message-wrapper';
  
  const bubble = document.createElement('div');
  bubble.className = `message-bubble ${msg.sender === 'user' ? 'user-message' : 'agent-message'}`;
  
  let content = msg.text || msg.message || '';
  let attachmentHtml = '';
  
  if (msg.attachment) {
    attachmentHtml = formatAttachment(msg.attachment);
  }
  
  const senderName = msg.sender === 'user' ? (msg.userName || 'User') : 'You';
  
  bubble.innerHTML = `
    <div class="message-meta">
      <span class="message-sender">${senderName}</span>
      <span class="message-time">${formatTime(msg.timestamp)}</span>
    </div>
    <div class="message-content">${content}</div>
    ${attachmentHtml}
  `;
  
  wrapper.appendChild(bubble);
  return wrapper;
}

function formatAttachment(attachment) {
  if (!attachment) return '';
  
  const fileType = attachment.mimetype ? attachment.mimetype.split('/')[0] : 'file';
  const fileUrl = attachment.url || attachment.path;
  const fileName = attachment.originalname || attachment.filename || 'file';
  const fileSize = attachment.size ? formatFileSize(attachment.size) : '';
  
  let icon = 'üìÑ';
  let preview = '';
  
  if (fileType === 'image') {
    icon = 'üñºÔ∏è';
    preview = `<img src="${fileUrl}" alt="${fileName}" loading="lazy" style="max-width: 100%; max-height: 200px; border-radius: 8px; margin-top: 8px;">`;
  } else if (fileType === 'video') {
    icon = 'üé¨';
    preview = `<video src="${fileUrl}" controls style="max-width: 100%; max-height: 200px; border-radius: 8px; margin-top: 8px;"></video>`;
  } else if (fileType === 'audio') {
    icon = 'üéµ';
    preview = `<audio src="${fileUrl}" controls style="width: 100%; margin-top: 8px;"></audio>`;
  }
  
  return `
    <div class="attachment">
      <a href="${fileUrl}" target="_blank" download="${fileName}">
        ${icon} ${fileName}
        ${fileSize ? `<span style="font-size: 0.9em; color: #666;">(${fileSize})</span>` : ''}
      </a>
      ${preview}
    </div>
  `;
}

function displayMessage(msg, userId, scroll = true) {
  if (!messages[userId]) {
    messages[userId] = [];
  }
  
  // Check for duplicates
  const isDuplicate = messages[userId].some(m => 
    m.id === msg.id || 
    (m.timestamp === msg.timestamp && m.text === msg.text && m.sender === msg.sender)
  );
  
  if (isDuplicate) {
    console.log('Skipping duplicate message:', msg);
    return;
  }
  
  messages[userId].push(msg);
  
  // If this is the active chat, display it
  if (userId === currentUserId) {
    const container = document.querySelector('.messages-container');
    if (!container) return;
    
    // Remove empty state if present
    const emptyState = container.querySelector('.empty-state');
    if (emptyState) {
      emptyState.remove();
    }
    
    const messageElement = createMessageElement(msg);
    container.appendChild(messageElement);
    
    // Auto-scroll if at bottom or this is our message
    if (scroll && (isScrolledToBottom || msg.sender === 'agent')) {
      setTimeout(() => {
        if (msg.sender === 'user') {
          scrollToBottomSmooth();
        } else if (isScrolledToBottom) {
          scrollToBottomSmooth();
        }
      }, 100);
    }
    
    // Save to storage
    Storage.saveMessages(userId, messages[userId]);
  }
}

function displayMessages(userId, msgArray) {
  const container = document.querySelector('.messages-container');
  if (!container) return;
  
  // Clear container
  container.innerHTML = '';
  
  if (!msgArray || msgArray.length === 0) {
    const emptyState = document.createElement('div');
    emptyState.className = 'empty-state';
    emptyState.innerHTML = `
      <div class="empty-state-icon">üí¨</div>
      <div class="empty-state-title">No messages yet</div>
      <div class="empty-state-subtitle">Start the conversation by sending a message</div>
    `;
    container.appendChild(emptyState);
    return;
  }
  
  // Sort messages by timestamp
  const sortedMessages = [...msgArray].sort((a, b) => 
    new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
  );
  
  // Store messages
  messages[userId] = sortedMessages;
  
  // Display messages
  const fragment = document.createDocumentFragment();
  sortedMessages.forEach(msg => {
    const element = createMessageElement(msg);
    fragment.appendChild(element);
  });
  
  container.appendChild(fragment);
  
  // Scroll to bottom
  setTimeout(scrollToBottom, 50);
}

function loadMessagesForUser(userId) {
  // Load from storage first
  const storedMessages = Storage.loadMessages(userId);
  
  if (storedMessages.length > 0) {
    console.log(`üìÇ Loaded ${storedMessages.length} messages from storage for ${userId}`);
    displayMessages(userId, storedMessages);
  }
  
  // Then request from server
  socket.emit('get_messages', { userId: userId });
}

// ===== MESSAGE SENDING =====
function sendMessage() {
  if (!currentUserId) {
    showNotification('Please select a user to chat with', 'error');
    return;
  }
  
  const input = document.querySelector('.message-input');
  const text = input.value.trim();
  const fileInput = document.getElementById('fileInput');
  
  if (!text && !selectedFile) {
    showNotification('Please enter a message or select a file', 'warning');
    return;
  }
  
  const canSend = SendController.canSend();
  if (!canSend.canSend) {
    showNotification('Please wait before sending another message', 'warning');
    return;
  }
  
  SendController.beginSend();
  
  const sendBtn = document.querySelector('.send-btn');
  const originalText = sendBtn.textContent;
  sendBtn.disabled = true;
  sendBtn.innerHTML = '<div class="loading"></div>';
  
  if (selectedFile) {
    uploadFile(function(fileInfo) {
      if (fileInfo) {
        sendMessageToServer(text, fileInfo);
      } else {
        SendController.finishSend();
        sendBtn.disabled = false;
        sendBtn.textContent = originalText;
      }
    });
  } else {
    sendMessageToServer(text);
  }
  
  input.value = '';
  input.style.height = 'auto';
  
  // Reset file selection
  selectedFile = null;
  const filePreview = document.querySelector('.upload-preview');
  if (filePreview) {
    filePreview.style.display = 'none';
  }
  if (fileInput) {
    fileInput.value = '';
  }
}

function sendMessageToServer(text, attachment = null) {
  const messageData = {
    userId: currentUserId,
    message: text,
    attachment: attachment
  };
  
  socket.emit('agent_message', messageData);
  
  // Create optimistic message
  const optimisticMsg = {
    id: 'temp_' + Date.now(),
    sender: 'agent',
    text: text,
    timestamp: new Date().toISOString(),
    attachment: attachment,
    optimistic: true
  };
  
  displayMessage(optimisticMsg, currentUserId);
  
  // Re-enable send button after a delay
  setTimeout(() => {
    const sendBtn = document.querySelector('.send-btn');
    if (sendBtn) {
      sendBtn.disabled = false;
      sendBtn.textContent = 'Send';
    }
    SendController.finishSend();
  }, 1000);
}

function uploadFile(callback) {
  if (!selectedFile) {
    callback(null);
    return;
  }
  
  const formData = new FormData();
  formData.append('file', selectedFile);
  
  const xhr = new XMLHttpRequest();
  const progressBar = document.querySelector('.progress-bar');
  const uploadPreview = document.querySelector('.upload-preview');
  
  if (uploadPreview) {
    uploadPreview.style.display = 'flex';
    uploadPreview.innerHTML = `üìé ${selectedFile.name} (${formatFileSize(selectedFile.size)})`;
  }
  
  if (progressBar) {
    progressBar.style.width = '0%';
  }
  
  xhr.upload.addEventListener('progress', (e) => {
    if (e.lengthComputable && progressBar) {
      const percentComplete = (e.loaded / e.total) * 100;
      progressBar.style.width = percentComplete + '%';
    }
  });
  
  xhr.onload = function() {
    if (xhr.status === 200) {
      try {
        const response = JSON.parse(xhr.responseText);
        if (response.success) {
          callback(response.file);
        } else {
          showNotification('Upload failed: ' + response.message, 'error');
          callback(null);
        }
      } catch (e) {
        showNotification('Upload failed: Invalid response', 'error');
        callback(null);
      }
    } else {
      showNotification('Upload failed with status: ' + xhr.status, 'error');
      callback(null);
    }
  };
  
  xhr.onerror = function() {
    showNotification('Upload failed. Please check your connection.', 'error');
    callback(null);
  };
  
  xhr.open('POST', '/upload');
  xhr.send(formData);
}

// ===== FILE HANDLING =====
function handleFileSelect(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  // Check file size (max 10MB)
  const maxSize = 10 * 1024 * 1024;
  if (file.size > maxSize) {
    showNotification('File size too large. Maximum size is 10MB.', 'error');
    event.target.value = '';
    return;
  }
  
  selectedFile = file;
}

// ===== NOTIFICATION SYSTEM =====
function showNotification(message, type = 'info') {
  // Remove existing notifications
  const existing = document.querySelector('.notification');
  if (existing) {
    existing.remove();
  }
  
  const notification = document.createElement('div');
  notification.className = `notification ${type}`;
  notification.textContent = message;
  
  document.body.appendChild(notification);
  
  // Auto-remove after 5 seconds
  setTimeout(() => {
    if (notification.parentNode) {
      notification.remove();
    }
  }, 5000);
}

// ===== TYPING INDICATOR =====
function showTypingIndicator(userId) {
  if (userId !== currentUserId) return;
  
  const container = document.querySelector('.messages-container');
  if (!container) return;
  
  // Remove existing typing indicator
  const existing = container.querySelector('.typing-indicator');
  if (existing) {
    existing.remove();
  }
  
  const indicator = document.createElement('div');
  indicator.className = 'typing-indicator';
  indicator.innerHTML = `
    <div class="typing-dot"></div>
    <div class="typing-dot"></div>
    <div class="typing-dot"></div>
  `;
  
  container.appendChild(indicator);
  scrollToBottomSmooth();
}

function hideTypingIndicator(userId) {
  if (userId !== currentUserId) return;
  
  const container = document.querySelector('.messages-container');
  if (!container) return;
  
  const indicator = container.querySelector('.typing-indicator');
  if (indicator) {
    indicator.remove();
  }
}

// ===== SOCKET EVENT HANDLERS =====
socket.on('connect', () => {
  console.log('‚úÖ Connected to server with ID:', socket.id);
  ConnectionManager.showStatus('connected', 'Connected');
  ConnectionManager.reset();
  
  // Register as agent
  socket.emit('register_agent', {
    agentId: 'agent_' + Date.now(),
    name: 'Support Agent'
  });
});

socket.on('disconnect', (reason) => {
  console.log('‚ùå Disconnected:', reason);
  ConnectionManager.showStatus('disconnected', 'Disconnected - Reconnecting...');
});

socket.on('connect_error', (error) => {
  console.error('üîå Connection error:', error);
  ConnectionManager.showStatus('error', 'Connection error');
});

socket.on('registered', (data) => {
  console.log('‚úÖ Registered as agent:', data);
});

socket.on('user_list', (users) => {
  console.log('üë• User list:', users);
  updateUserList(users);
});

socket.on('new_message', (msg) => {
  console.log('üì® New message:', msg);
  
  const userId = msg.userId || msg.senderId;
  if (userId) {
    displayMessage(msg, userId);
    
    // Update user list preview
    const userItem = document.querySelector(`[data-user-id="${userId}"]`);
    if (userItem) {
      const preview = userItem.querySelector('.user-preview');
      if (preview) {
        preview.textContent = msg.text || msg.message || 'Attachment';
      }
    }
  }
});

socket.on('message_history', (data) => {
  console.log('üìú Message history for', data.userId, ':', data.messages.length, 'messages');
  
  const storedMessages = Storage.loadMessages(data.userId);
  const allMessages = mergeMessages(storedMessages, data.messages);
  
  if (data.userId === currentUserId) {
    displayMessages(data.userId, allMessages);
  }
  
  Storage.saveMessages(data.userId, allMessages);
});

socket.on('user_typing', (data) => {
  if (data.userId === currentUserId) {
    showTypingIndicator(data.userId);
    
    // Clear previous timeout
    if (userTypingTimeout) {
      clearTimeout(userTypingTimeout);
    }
    
    // Hide typing indicator after 3 seconds
    userTypingTimeout = setTimeout(() => {
      hideTypingIndicator(data.userId);
    }, 3000);
  }
});

socket.on('user_stop_typing', (data) => {
  if (data.userId === currentUserId) {
    hideTypingIndicator(data.userId);
  }
});

socket.on('user_connected', (user) => {
  console.log('üü¢ User connected:', user);
  showNotification(`${user.name} is now online`, 'success');
});

socket.on('user_disconnected', (user) => {
  console.log('üî¥ User disconnected:', user);
  showNotification(`${user.name} is now offline`, 'warning');
});

// ===== MESSAGE MERGING =====
function mergeMessages(localMessages, serverMessages) {
  const messageMap = new Map();
  
  // Add local messages
  localMessages.forEach(msg => {
    if (msg.id && !msg.optimistic) {
      messageMap.set(msg.id, msg);
    }
  });
  
  // Add/overwrite with server messages
  serverMessages.forEach(msg => {
    if (msg.id) {
      messageMap.set(msg.id, msg);
    }
  });
  
  // Convert to array and sort
  const merged = Array.from(messageMap.values());
  merged.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
  
  return merged;
}

// ===== EVENT LISTENERS =====
function setupEventListeners() {
  // Back button
  const backBtn = document.querySelector('.back-button');
  if (backBtn) {
    backBtn.addEventListener('click', hideChatDetail);
  }
  
  // Send button
  const sendBtn = document.querySelector('.send-btn');
  if (sendBtn) {
    sendBtn.addEventListener('click', sendMessage);
  }
  
  // Message input
  const messageInput = document.querySelector('.message-input');
  if (messageInput) {
    messageInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });
    
    // Auto-resize
    messageInput.addEventListener('input', function() {
      this.style.height = 'auto';
      this.style.height = Math.min(this.scrollHeight, 120) + 'px';
    });
    
    // Typing indicator
    let typingTimeout;
    messageInput.addEventListener('input', () => {
      if (currentUserId) {
        socket.emit('agent_typing', { userId: currentUserId });
        
        clearTimeout(typingTimeout);
        typingTimeout = setTimeout(() => {
          socket.emit('agent_stop_typing', { userId: currentUserId });
        }, 1000);
      }
    });
  }
  
  // File input
  const fileInput = document.getElementById('fileInput');
  if (fileInput) {
    fileInput.addEventListener('change', handleFileSelect);
  }
  
  // File attach button
  const attachBtn = document.querySelector('.file-attach-btn');
  if (attachBtn) {
    attachBtn.addEventListener('click', () => {
      fileInput.click();
    });
  }
  
  // Handle mobile back button
  window.addEventListener('popstate', (e) => {
    if (document.querySelector('.chat-detail-view.active')) {
      hideChatDetail();
      history.pushState(null, '', window.location.pathname);
    }
  });
}

// ===== INITIALIZATION =====
function init() {
  console.log('üöÄ Initializing agent chat...');
  
  // Initialize managers
  ConnectionManager.init();
  
  // Setup event listeners
  setupEventListeners();
  
  // Initialize scrolling (MINIMAL ADDITION)
  initScrolling();
  
  // Load any saved state
  const savedState = Storage.load('state');
  if (savedState) {
    console.log('üì± Restored saved state');
  }
  
  console.log('‚úÖ Agent chat initialized');
}

// ===== CLEANUP =====
window.addEventListener('beforeunload', () => {
  // Save all messages
  Object.keys(messages).forEach(userId => {
    Storage.saveMessages(userId, messages[userId]);
  });
  
  // Save state
  Storage.save('state', {
    currentUserId: currentUserId,
    lastActive: Date.now()
  });
  
  // Send disconnect event
  if (socket.connected) {
    socket.emit('agent_disconnecting');
  }
});

// ===== START APPLICATION =====
document.addEventListener('DOMContentLoaded', init);