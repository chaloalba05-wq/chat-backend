<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Agent Dashboard</title>
<script src="/socket.io/socket.io.js"></script>
<style>
body { font-family: Arial; display: flex; flex-direction: column; height: 100vh; margin: 0; background: #f9f9f9; }
header { padding: 10px; background: #222; color: #fff; display: flex; justify-content: space-between; align-items: center; }
#dashboard { display: flex; flex: 1; overflow: hidden; }
#activeMessages { flex: 0 0 250px; overflow-y: auto; border-right: 1px solid #ccc; padding: 10px; background: #fff; }
.user-item { padding: 8px; cursor: pointer; border-bottom: 1px solid #eee; border-radius: 4px; margin-bottom: 5px; }
.user-item:hover { background: #f0f0f0; }
.user-item.highlight { background: #ffd27f !important; }
.message-item { font-size: 0.9em; margin-left: 10px; color: #333; }
.read-indicator { font-size: 0.8em; color: #4CAF50; font-weight: bold; margin-left: 5px; }
.unread-indicator { font-size: 0.8em; color: #FF5722; font-weight: bold; margin-left: 5px; }
#main { flex: 1; padding: 10px; }
.status { font-weight: bold; }
.empty-message { font-style: italic; color: #888; }
</style>
</head>
<body>
<header>
  <h2>Agent Dashboard</h2>
  <div>
    Connection: <span id="connectionStatus" class="status">Connecting...</span> | 
    Unread: <span id="unreadCount">0</span>
  </div>
</header>

<div id="dashboard">
  <div id="activeMessages"><div class="empty-message">No active users</div></div>
  <div id="main">Select a user to open chat</div>
</div>

<script>
const agentId = "agent1";
const agentPassword = "agent1";

// Check if agent is verified (you might want to implement proper login)
if (!localStorage.getItem("agentVerified")) {
  // Uncomment this if you have a login page
  // window.location.href = "login.html";
}

const socket = io({ 
  reconnection: true, 
  reconnectionAttempts: Infinity, 
  reconnectionDelay: 1000, 
  reconnectionDelayMax: 5000 
});

const connectionStatus = document.getElementById("connectionStatus");

// ===== SOCKET CONNECTION HANDLING =====
socket.on("connect", () => { 
  console.log("Socket connected:", socket.id);
  connectionStatus.textContent = "Connected"; 
  connectionStatus.style.color = "green"; 
  loginAgent();
});

socket.on("disconnect", () => { 
  console.log("Socket disconnected");
  connectionStatus.textContent = "Disconnected"; 
  connectionStatus.style.color = "red"; 
});

socket.on("reconnect_attempt", () => { 
  connectionStatus.textContent = "Reconnecting..."; 
  connectionStatus.style.color = "orange"; 
});

socket.on("reconnect", () => {
  console.log("Socket reconnected");
  connectionStatus.textContent = "Connected"; 
  connectionStatus.style.color = "green";
  loginAgent();
});

// ===== AGENT AUTHENTICATION =====
function loginAgent() {
  console.log("Attempting agent login...");
  socket.emit("agent_login", { 
    agentId, 
    password: agentPassword, 
    persistent: true 
  });
}

socket.on("agent_login_response", (res) => {
  console.log("Login response:", res);
  if(res.success){
    console.log("✅ Agent logged in successfully");
    // Request initial user list from server
    socket.emit("get_user_list_with_read_receipts");
  } else {
    console.error("❌ Agent login failed:", res.message);
    // Try to register the agent first
    socket.emit("register_permanent_agent", { 
      id: agentId, 
      name: agentId, 
      password: agentPassword 
    });
  }
});

socket.on("agent_registration_response", (res) => {
  console.log("Registration response:", res);
  if(res.success) {
    console.log("✅ Agent registered, attempting login...");
    loginAgent();
  }
});

// ===== DATA STORAGE =====
let allUsers = [];
let unreadMessages = JSON.parse(localStorage.getItem("unreadMessages")) || {};

function saveUnreadMessages() { 
  localStorage.setItem("unreadMessages", JSON.stringify(unreadMessages)); 
}

function updateUnreadCount() {
  let count = 0;
  for (const whatsapp in unreadMessages) {
    count += unreadMessages[whatsapp].length || 0;
  }
  document.getElementById("unreadCount").textContent = count;
}

// ===== USER LIST MANAGEMENT =====
socket.on("user_list_with_read_receipts", (data) => {
  console.log("Received user list update:", data);
  
  if (data && data.users && Array.isArray(data.users)) {
    // Process the user list from server
    allUsers = data.users.map(user => ({
      whatsapp: user.whatsapp,
      lastMessage: user.lastMessage || "",
      lastMessageTime: user.lastMessageTime || new Date(),
      unreadCount: user.unreadCount || 0,
      lastMessageDetails: user.lastMessageDetails || null
    }));
    
    // Update unread messages based on server data
    data.users.forEach(user => {
      if (user.unreadCount > 0) {
        if (!unreadMessages[user.whatsapp]) {
          unreadMessages[user.whatsapp] = [];
        }
        
        // Add placeholder entries for unread messages
        while (unreadMessages[user.whatsapp].length < user.unreadCount) {
          unreadMessages[user.whatsapp].push({
            id: `temp_${Date.now()}_${unreadMessages[user.whatsapp].length}`,
            text: user.lastMessage || "New message",
            timestamp: new Date()
          });
        }
      } else {
        // Clear if no unread messages
        delete unreadMessages[user.whatsapp];
      }
    });
    
    saveUnreadMessages();
    updateUserList();
    updateUnreadCount();
  }
});

function updateUserList() {
  const container = document.getElementById("activeMessages");
  container.innerHTML = "";

  if (allUsers.length === 0) {
    const empty = document.createElement("div");
    empty.textContent = "No active users";
    empty.className = "empty-message";
    container.appendChild(empty);
    updateUnreadCount();
    return;
  }

  // Sort by unread count (highest first), then by last message time
  allUsers.sort((a, b) => {
    if (b.unreadCount !== a.unreadCount) {
      return b.unreadCount - a.unreadCount;
    }
    return new Date(b.lastMessageTime) - new Date(a.lastMessageTime);
  });

  allUsers.forEach(user => {
    const div = document.createElement("div");
    div.className = "user-item";
    
    if (user.unreadCount > 0) {
      div.classList.add("highlight");
    }
    
    const title = document.createElement("div");
    title.textContent = `${user.whatsapp} ${user.unreadCount > 0 ? `(${user.unreadCount})` : ''}`;
    div.appendChild(title);

    // Show last message preview
    if (user.lastMessage) {
      const msgDiv = document.createElement("div");
      msgDiv.className = "message-item";
      const messageText = user.lastMessage.length > 40 ? 
        user.lastMessage.substring(0, 40) + '...' : user.lastMessage;
      msgDiv.textContent = messageText;
      div.appendChild(msgDiv);
    }

    // Show time of last message
    if (user.lastMessageTime) {
      const timeDiv = document.createElement("div");
      timeDiv.className = "message-item";
      timeDiv.style.fontSize = "0.8em";
      timeDiv.style.color = "#666";
      const time = new Date(user.lastMessageTime);
      const now = new Date();
      const diffMs = now - time;
      const diffMins = Math.floor(diffMs / 60000);
      
      if (diffMins < 1) {
        timeDiv.textContent = "just now";
      } else if (diffMins < 60) {
        timeDiv.textContent = `${diffMins}m ago`;
      } else if (diffMins < 1440) {
        timeDiv.textContent = `${Math.floor(diffMins / 60)}h ago`;
      } else {
        timeDiv.textContent = time.toLocaleDateString();
      }
      div.appendChild(timeDiv);
    }

    div.addEventListener("click", () => {
      // Open chat in new window/tab
      window.open(`agent-chat.html?whatsapp=${user.whatsapp}`, "_blank");
      
      // Clear unread messages for this user
      if (unreadMessages[user.whatsapp]) {
        delete unreadMessages[user.whatsapp];
        saveUnreadMessages();
      }
      
      // Update the UI
      updateUserList();
      updateUnreadCount();
    });

    container.appendChild(div);
  });

  updateUnreadCount();
}

// ===== REAL-TIME MESSAGE HANDLING =====
socket.on("new_message", handleMessageEvent);

function handleMessageEvent(msg) {
  console.log("New message received:", msg);
  
  // Ignore messages from agents
  if (msg.sender === 'agent') return;
  
  // Ignore already read messages
  if (msg.read) return;
  
  // Check if this is a broadcast message
  if (msg.isBroadcast) {
    // Handle broadcast messages differently if needed
    console.log("Broadcast message received:", msg);
    return;
  }
  
  const whatsapp = msg.whatsapp;
  
  // Update unread messages
  if (!unreadMessages[whatsapp]) {
    unreadMessages[whatsapp] = [];
  }
  
  // Check if this message is already tracked
  const existingIndex = unreadMessages[whatsapp].findIndex(m => m.id === msg.id);
  if (existingIndex === -1) {
    unreadMessages[whatsapp].push({
      id: msg.id,
      text: msg.text || (msg.attachment ? '[Attachment]' : 'New message'),
      timestamp: msg.timestamp || new Date()
    });
  }
  
  // Check if user exists in our list
  const existingUser = allUsers.find(u => u.whatsapp === whatsapp);
  if (!existingUser) {
    // Add new user to list
    allUsers.push({
      whatsapp: whatsapp,
      lastMessage: msg.text || (msg.attachment ? '[Attachment]' : ''),
      lastMessageTime: msg.timestamp || new Date(),
      unreadCount: (unreadMessages[whatsapp]?.length || 0) + 1
    });
  } else {
    // Update existing user
    existingUser.lastMessage = msg.text || (msg.attachment ? '[Attachment]' : '');
    existingUser.lastMessageTime = msg.timestamp || new Date();
    existingUser.unreadCount = unreadMessages[whatsapp]?.length || 0;
  }
  
  saveUnreadMessages();
  updateUserList();
  updateUnreadCount();
  
  // Trigger notifications
  if (document.hidden) {
    playNotificationSound();
    notifyUser("New message from " + whatsapp, 
      msg.text || (msg.attachment ? 'Sent an attachment' : 'New message'));
  }
}

// Handle read receipt updates
socket.on("messages_read_update", (updateData) => {
  console.log("Messages read update:", updateData);
  
  const { whatsapp, messageIds } = updateData;
  if (whatsapp && messageIds && Array.isArray(messageIds) && messageIds.length > 0) {
    if (unreadMessages[whatsapp]) {
      // Remove the read messages from our unread list
      unreadMessages[whatsapp] = unreadMessages[whatsapp].filter(
        msg => !messageIds.includes(msg.id)
      );
      
      // Clean up if empty
      if (unreadMessages[whatsapp].length === 0) {
        delete unreadMessages[whatsapp];
      }
      
      // Update user in list
      const user = allUsers.find(u => u.whatsapp === whatsapp);
      if (user) {
        user.unreadCount = unreadMessages[whatsapp]?.length || 0;
      }
      
      saveUnreadMessages();
      updateUserList();
      updateUnreadCount();
    }
  }
});

// Handle chat deletions/archiving
socket.on("chat_deleted", handleChatRemoval);
socket.on("chat_archived", handleChatRemoval);

function handleChatRemoval(data) {
  const { whatsapp } = data;
  if (whatsapp) {
    // Remove from our lists
    allUsers = allUsers.filter(u => u.whatsapp !== whatsapp);
    if (unreadMessages[whatsapp]) {
      delete unreadMessages[whatsapp];
    }
    
    saveUnreadMessages();
    updateUserList();
    updateUnreadCount();
    
    console.log(`Chat removed: ${whatsapp}`);
  }
}

// ===== NOTIFICATIONS =====
function playNotificationSound() {
  try {
    const context = new (window.AudioContext || window.webkitAudioContext)();
    let count = 0;
    const interval = setInterval(() => {
      const oscillator = context.createOscillator();
      const gainNode = context.createGain();
      oscillator.type = 'sine';
      oscillator.frequency.value = 880;
      gainNode.gain.value = 0.3;
      oscillator.connect(gainNode);
      gainNode.connect(context.destination);
      oscillator.start();
      oscillator.stop(context.currentTime + 0.1);
      count++;
      if (count >= 3) clearInterval(interval);
    }, 150);
  } catch(e) {
    console.error("Audio error:", e);
  }
}

function requestNotificationPermission() {
  if ("Notification" in window && Notification.permission === "default") {
    Notification.requestPermission();
  }
}

function notifyUser(title, body) {
  if ("Notification" in window && Notification.permission === "granted") {
    const notification = new Notification(title, { 
      body, 
      icon: "/favicon.ico" 
    });
    notification.onclick = () => {
      window.focus();
      notification.close();
    };
    
    // Auto-close after 5 seconds
    setTimeout(() => notification.close(), 5000);
  }
}

// ===== INITIALIZATION =====
window.addEventListener("DOMContentLoaded", () => {
  console.log("Dashboard loaded");
  requestNotificationPermission();
  updateUserList();
  updateUnreadCount();
  
  // Refresh user list every 30 seconds to stay in sync
  setInterval(() => {
    if (socket.connected) {
      socket.emit("get_user_list_with_read_receipts");
    }
  }, 30000);
});

// Handle page visibility changes
document.addEventListener("visibilitychange", () => {
  if (!document.hidden && socket.connected) {
    // Page is now visible, refresh data
    socket.emit("get_user_list_with_read_receipts");
  }
});

// Handle beforeunload to clean up
window.addEventListener("beforeunload", () => {
  if (socket.connected) {
    socket.disconnect();
  }
});
</script>
</body>
</html>