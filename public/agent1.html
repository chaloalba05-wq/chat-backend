<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Agent Dashboard</title>
<script src="/socket.io/socket.io.js"></script>
<style>
body { font-family: Arial; display: flex; flex-direction: column; height: 100vh; margin: 0; background: #f9f9f9; }
header { padding: 10px; background: #222; color: #fff; display: flex; justify-content: space-between; align-items: center; }
#dashboard { flex: 1; overflow: hidden; }
#activeMessages { width: 100%; height: 100%; overflow-y: auto; padding: 10px; background: #fff; }
.user-item { padding: 8px; cursor: pointer; border-bottom: 1px solid #eee; border-radius: 4px; margin-bottom: 5px; }
.user-item:hover { background: #f0f0f0; }
.user-item.highlight { background: #ffd27f !important; }
.message-item { font-size: 0.9em; margin-left: 10px; color: #333; }
.read-indicator { font-size: 0.8em; color: #4CAF50; font-weight: bold; margin-left: 5px; }
.unread-indicator { font-size: 0.8em; color: #FF5722; font-weight: bold; margin-left: 5px; }
.status { font-weight: bold; }
.empty-message { font-style: italic; color: #888; }
</style>
</head>
<body>
<header>
  <h2>Agent Dashboard</h2>
  <div>
    Connection: <span id="connectionStatus" class="status">Connecting...</span> | 
    Unread: <span id="unreadCount">0</span>
  </div>
</header>

<div id="dashboard">
  <div id="activeMessages"><div class="empty-message">No active users</div></div>
</div>

<script>
const agentId = "agent1";
const agentPassword = "agent1";

const socket = io({ 
  reconnection: true, 
  reconnectionAttempts: Infinity, 
  reconnectionDelay: 1000, 
  reconnectionDelayMax: 5000 
});

const connectionStatus = document.getElementById("connectionStatus");

socket.on("connect", () => { 
  connectionStatus.textContent = "Connected"; 
  connectionStatus.style.color = "green"; 
  loginAgent();
});

socket.on("disconnect", () => { 
  connectionStatus.textContent = "Disconnected"; 
  connectionStatus.style.color = "red"; 
});

socket.on("reconnect_attempt", () => { 
  connectionStatus.textContent = "Reconnecting..."; 
  connectionStatus.style.color = "orange"; 
});

socket.on("reconnect", () => {
  connectionStatus.textContent = "Connected"; 
  connectionStatus.style.color = "green";
  loginAgent();
});

function loginAgent() {
  socket.emit("agent_login", { 
    agentId, 
    password: agentPassword, 
    persistent: true 
  });
}

socket.on("agent_login_response", (res) => {
  if(res.success){
    socket.emit("get_user_list_with_read_receipts");
  } else {
    socket.emit("register_permanent_agent", { 
      id: agentId, 
      name: agentId, 
      password: agentPassword 
    });
  }
});

socket.on("agent_registration_response", (res) => {
  if(res.success) {
    loginAgent();
  }
});

let allUsers = [];
let unreadMessages = JSON.parse(localStorage.getItem("unreadMessages")) || {};

function saveUnreadMessages() { 
  localStorage.setItem("unreadMessages", JSON.stringify(unreadMessages)); 
}

function updateUnreadCount() {
  let count = 0;
  for (const whatsapp in unreadMessages) {
    count += unreadMessages[whatsapp].length || 0;
  }
  document.getElementById("unreadCount").textContent = count;
}

socket.on("user_list_with_read_receipts", (data) => {
  if (data && data.users && Array.isArray(data.users)) {
    allUsers = data.users.map(user => ({
      whatsapp: user.whatsapp,
      lastMessage: user.lastMessage || "",
      lastMessageTime: user.lastMessageTime || new Date(),
      unreadCount: user.unreadCount || 0,
      lastMessageDetails: user.lastMessageDetails || null
    }));
    
    data.users.forEach(user => {
      if (user.unreadCount > 0) {
        if (!unreadMessages[user.whatsapp]) {
          unreadMessages[user.whatsapp] = [];
        }
        while (unreadMessages[user.whatsapp].length < user.unreadCount) {
          unreadMessages[user.whatsapp].push({
            id: `temp_${Date.now()}_${unreadMessages[user.whatsapp].length}`,
            text: user.lastMessage || "New message",
            timestamp: new Date()
          });
        }
      } else {
        delete unreadMessages[user.whatsapp];
      }
    });
    
    saveUnreadMessages();
    updateUserList();
    updateUnreadCount();
  }
});

function updateUserList() {
  const container = document.getElementById("activeMessages");
  container.innerHTML = "";

  if (allUsers.length === 0) {
    const empty = document.createElement("div");
    empty.textContent = "No active users";
    empty.className = "empty-message";
    container.appendChild(empty);
    updateUnreadCount();
    return;
  }

  allUsers.sort((a, b) => {
    if (b.unreadCount !== a.unreadCount) {
      return b.unreadCount - a.unreadCount;
    }
    return new Date(b.lastMessageTime) - new Date(a.lastMessageTime);
  });

  allUsers.forEach(user => {
    const div = document.createElement("div");
    div.className = "user-item";
    
    if (user.unreadCount > 0) {
      div.classList.add("highlight");
    }
    
    const title = document.createElement("div");
    title.textContent = `${user.whatsapp} ${user.unreadCount > 0 ? `(${user.unreadCount})` : ''}`;
    div.appendChild(title);

    if (user.lastMessage) {
      const msgDiv = document.createElement("div");
      msgDiv.className = "message-item";
      const messageText = user.lastMessage.length > 40 ? 
        user.lastMessage.substring(0, 40) + '...' : user.lastMessage;
      msgDiv.textContent = messageText;
      div.appendChild(msgDiv);
    }

    if (user.lastMessageTime) {
      const timeDiv = document.createElement("div");
      timeDiv.className = "message-item";
      timeDiv.style.fontSize = "0.8em";
      timeDiv.style.color = "#666";
      const time = new Date(user.lastMessageTime);
      const now = new Date();
      const diffMs = now - time;
      const diffMins = Math.floor(diffMs / 60000);
      
      if (diffMins < 1) {
        timeDiv.textContent = "just now";
      } else if (diffMins < 60) {
        timeDiv.textContent = `${diffMins}m ago`;
      } else if (diffMins < 1440) {
        timeDiv.textContent = `${Math.floor(diffMins / 60)}h ago`;
      } else {
        timeDiv.textContent = time.toLocaleDateString();
      }
      div.appendChild(timeDiv);
    }

    div.addEventListener("click", () => {
      // Encode WhatsApp number to handle + and special characters
      const encodedWhatsApp = encodeURIComponent(user.whatsapp);
      window.open(`agent-chat.html?whatsapp=${encodedWhatsApp}`, "_blank");
      
      if (unreadMessages[user.whatsapp]) {
        delete unreadMessages[user.whatsapp];
        saveUnreadMessages();
      }
      
      updateUserList();
      updateUnreadCount();
    });

    container.appendChild(div);
  });

  updateUnreadCount();
}

socket.on("new_message", handleMessageEvent);

function handleMessageEvent(msg) {
  if (msg.sender === 'agent' || msg.read) return;
  if (msg.isBroadcast) return;
  
  const whatsapp = msg.whatsapp;
  
  if (!unreadMessages[whatsapp]) {
    unreadMessages[whatsapp] = [];
  }
  
  const existingIndex = unreadMessages[whatsapp].findIndex(m => m.id === msg.id);
  if (existingIndex === -1) {
    unreadMessages[whatsapp].push({
      id: msg.id,
      text: msg.text || (msg.attachment ? '[Attachment]' : 'New message'),
      timestamp: msg.timestamp || new Date()
    });
  }
  
  const existingUser = allUsers.find(u => u.whatsapp === whatsapp);
  if (!existingUser) {
    allUsers.push({
      whatsapp: whatsapp,
      lastMessage: msg.text || (msg.attachment ? '[Attachment]' : ''),
      lastMessageTime: msg.timestamp || new Date(),
      unreadCount: (unreadMessages[whatsapp]?.length || 0) + 1
    });
  } else {
    existingUser.lastMessage = msg.text || (msg.attachment ? '[Attachment]' : '');
    existingUser.lastMessageTime = msg.timestamp || new Date();
    existingUser.unreadCount = unreadMessages[whatsapp]?.length || 0;
  }
  
  saveUnreadMessages();
  updateUserList();
  updateUnreadCount();
  
  if (document.hidden) {
    playNotificationSound();
    notifyUser("New message from " + whatsapp, 
      msg.text || (msg.attachment ? 'Sent an attachment' : 'New message'));
  }
}

socket.on("messages_read_update", (updateData) => {
  const { whatsapp, messageIds } = updateData;
  if (whatsapp && messageIds && Array.isArray(messageIds) && messageIds.length > 0) {
    if (unreadMessages[whatsapp]) {
      unreadMessages[whatsapp] = unreadMessages[whatsapp].filter(
        msg => !messageIds.includes(msg.id)
      );
      if (unreadMessages[whatsapp].length === 0) {
        delete unreadMessages[whatsapp];
      }
      const user = allUsers.find(u => u.whatsapp === whatsapp);
      if (user) {
        user.unreadCount = unreadMessages[whatsapp]?.length || 0;
      }
      saveUnreadMessages();
      updateUserList();
      updateUnreadCount();
    }
  }
});

socket.on("chat_deleted", handleChatRemoval);
socket.on("chat_archived", handleChatRemoval);

function handleChatRemoval(data) {
  const { whatsapp } = data;
  if (whatsapp) {
    allUsers = allUsers.filter(u => u.whatsapp !== whatsapp);
    if (unreadMessages[whatsapp]) delete unreadMessages[whatsapp];
    saveUnreadMessages();
    updateUserList();
    updateUnreadCount();
  }
}

function playNotificationSound() {
  try {
    const context = new (window.AudioContext || window.webkitAudioContext)();
    let count = 0;
    const interval = setInterval(() => {
      const oscillator = context.createOscillator();
      const gainNode = context.createGain();
      oscillator.type = 'sine';
      oscillator.frequency.value = 880;
      gainNode.gain.value = 0.3;
      oscillator.connect(gainNode);
      gainNode.connect(context.destination);
      oscillator.start();
      oscillator.stop(context.currentTime + 0.1);
      count++;
      if (count >= 3) clearInterval(interval);
    }, 150);
  } catch(e) {
    console.error("Audio error:", e);
  }
}

function requestNotificationPermission() {
  if ("Notification" in window && Notification.permission === "default") {
    Notification.requestPermission();
  }
}

function notifyUser(title, body) {
  if ("Notification" in window && Notification.permission === "granted") {
    const notification = new Notification(title, { 
      body, 
      icon: "/favicon.ico" 
    });
    notification.onclick = () => { window.focus(); notification.close(); };
    setTimeout(() => notification.close(), 5000);
  }
}

window.addEventListener("DOMContentLoaded", () => {
  requestNotificationPermission();
  updateUserList();
  updateUnreadCount();
  setInterval(() => {
    if (socket.connected) socket.emit("get_user_list_with_read_receipts");
  }, 30000);
});

document.addEventListener("visibilitychange", () => {
  if (!document.hidden && socket.connected) {
    socket.emit("get_user_list_with_read_receipts");
  }
});

window.addEventListener("beforeunload", () => {
  if (socket.connected) socket.disconnect();
});
</script>
</body>
</html>
