<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Agent Dashboard</title>
<script src="/socket.io/socket.io.js"></script>
<style>
body { font-family: Arial; display: flex; flex-direction: column; height: 100vh; margin: 0; background: #f9f9f9; }
header { padding: 10px; background: #222; color: #fff; display: flex; justify-content: space-between; align-items: center; }
#dashboard { display: flex; flex: 1; overflow: hidden; }
#activeMessages { flex: 0 0 250px; overflow-y: auto; border-right: 1px solid #ccc; padding: 10px; background: #fff; }
.user-item { padding: 8px; cursor: pointer; border-bottom: 1px solid #eee; border-radius: 4px; margin-bottom: 5px; }
.user-item:hover { background: #f0f0f0; }
.user-item.highlight { background: #ffd27f !important; }
.message-item { font-size: 0.9em; margin-left: 10px; color: #333; }
#main { flex: 1; padding: 10px; }
.status { font-weight: bold; }
.empty-message { font-style: italic; color: #888; }
</style>
</head>
<body>
<header>
  <h2>Agent Dashboard</h2>
  <div>
    Connection: <span id="connectionStatus" class="status">Connecting...</span> | 
    Unread: <span id="unreadCount">0</span>
  </div>
</header>

<div id="dashboard">
  <div id="activeMessages"><div class="empty-message">No active users</div></div>
  <div id="main">Select a user to open chat</div>
</div>

<script>
const agentId = "agent1";
const agentPassword = "agent1";

if (!localStorage.getItem("agentVerified")) window.location.href = "login.html";

const socket = io({ reconnection: true, reconnectionAttempts: Infinity, reconnectionDelay: 1000, reconnectionDelayMax: 5000 });

const connectionStatus = document.getElementById("connectionStatus");

socket.on("connect", () => { 
  connectionStatus.textContent = "Connected"; 
  connectionStatus.style.color = "green"; 
  registerAgent();
});

socket.on("disconnect", () => { 
  connectionStatus.textContent = "Disconnected"; 
  connectionStatus.style.color = "red"; 
});

socket.on("reconnect_attempt", () => { 
  connectionStatus.textContent = "Reconnecting..."; 
  connectionStatus.style.color = "orange"; 
});

function registerAgent() {
  socket.emit("register_permanent_agent", { id: agentId, name: agentId, password: agentPassword });
  loginAgent();
}

function loginAgent() {
  socket.emit("agent_login", { agentId, password: agentPassword, persistent: true });
}

socket.on("agent_login_response", (res) => {
  if(res.success){
    console.log("Agent logged in successfully");
    fetchActiveUsers();
  } else {
    console.error("Agent login failed:", res.message);
  }
});

let allUsers = [];
function fetchActiveUsers() {
  socket.emit("get_existing_users");
}

socket.on("existing_users", (users) => {
  // Merge users without overwriting unread messages
  users.forEach(u => {
    if(!allUsers.find(x => x.whatsapp === u.whatsapp)) allUsers.push({ whatsapp: u.whatsapp });
  });
  updateUserList(allUsers);
});

let unreadMessages = JSON.parse(localStorage.getItem("unreadMessages")) || {};
function saveUnreadMessages() {
  localStorage.setItem("unreadMessages", JSON.stringify(unreadMessages));
}

function updateUnreadCount() {
  let count = 0;
  for (const user in unreadMessages) {
    count += Object.keys(unreadMessages[user]).length;
  }
  document.getElementById("unreadCount").textContent = count;
}

function updateUserList(users){
  allUsers = users;
  const container = document.getElementById("activeMessages");
  container.innerHTML = "";

  if(users.length === 0){
    const empty = document.createElement("div");
    empty.textContent = "No active users";
    empty.className = "empty-message";
    container.appendChild(empty);
    updateUnreadCount();
    return;
  }

  users.sort((a,b)=>{
    const aUnread = unreadMessages[a.whatsapp] ? 1 : 0;
    const bUnread = unreadMessages[b.whatsapp] ? 1 : 0;
    return bUnread - aUnread;
  });

  users.forEach(u => {
    const div = document.createElement("div");
    div.className = "user-item";
    if(unreadMessages[u.whatsapp] && Object.keys(unreadMessages[u.whatsapp]).length > 0){
      div.classList.add("highlight");
    }
    const title = document.createElement("div");
    title.textContent = u.whatsapp;
    div.appendChild(title);

    if(unreadMessages[u.whatsapp]){
      for(const msgId in unreadMessages[u.whatsapp]){
        const msgDiv = document.createElement("div");
        msgDiv.className = "message-item";
        msgDiv.textContent = unreadMessages[u.whatsapp][msgId];
        div.appendChild(msgDiv);
      }
    }

    div.addEventListener("click", () => {
      window.open(`agent-chat.html?whatsapp=${u.whatsapp}`, "_blank");
      if(unreadMessages[u.whatsapp]){
        delete unreadMessages[u.whatsapp];
        saveUnreadMessages();
      }
      updateUserList(allUsers);
      updateUnreadCount();
    });

    container.appendChild(div);
  });

  updateUnreadCount();
}

function playNotificationSound(){
  try{
    const context = new (window.AudioContext||window.webkitAudioContext)();
    let count = 0;
    const interval = setInterval(()=>{
      const oscillator = context.createOscillator();
      const gainNode = context.createGain();
      oscillator.type = 'sine';
      oscillator.frequency.value = 880;
      gainNode.gain.value = 0.5;
      oscillator.connect(gainNode);
      gainNode.connect(context.destination);
      oscillator.start();
      oscillator.stop(context.currentTime+0.2);
      count++;
      if(count>=15) clearInterval(interval);
    }, 200);
  }catch(e){console.error(e);}
}

function requestNotificationPermission() {
  if("Notification" in window && Notification.permission !== "granted"){
    Notification.requestPermission();
  }
}

function notifyUser(title, body) {
  if("Notification" in window && Notification.permission === "granted"){
    const notification = new Notification(title, { body, icon: "notification.png" });
    notification.onclick = () => window.focus();
  }
}

// ===== REAL-TIME EVENTS =====
socket.on("new_message", handleMessageEvent);
socket.on("message_update", handleMessageEvent);
socket.on("chat_deleted", handleMessageEvent);
socket.on("chat_archived", handleMessageEvent);
socket.on("broadcast_message", handleMessageEvent);

socket.on("new_user", (newUser) => {
  if(newUser && !allUsers.find(u => u.whatsapp === newUser.whatsapp)){
    allUsers.push({ whatsapp: newUser.whatsapp });
    updateUserList(allUsers);
  }
});

// ===== HANDLE MESSAGE =====
function handleMessageEvent(msg){
  if(msg.whatsapp && msg.id){
    // Ensure user exists in allUsers
    if(!allUsers.find(u => u.whatsapp === msg.whatsapp)){
      allUsers.push({ whatsapp: msg.whatsapp });
    }

    if(!unreadMessages[msg.whatsapp]) unreadMessages[msg.whatsapp] = {};
    unreadMessages[msg.whatsapp][msg.id] = msg.text || "New message";
    saveUnreadMessages();
    updateUnreadCount();
    updateUserList(allUsers);
    playNotificationSound();
    notifyUser("New message from " + msg.whatsapp, msg.text || "You have a new message waiting in the dashboard");
  }
}

fetchActiveUsers();

window.addEventListener("DOMContentLoaded", () => {
  requestNotificationPermission();
  updateUserList(allUsers);
  updateUnreadCount();
});
</script>
</body>
</html>
