<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Agent Dashboard</title>
<script src="/socket.io/socket.io.js"></script>
<style>
body { font-family: Arial; display: flex; flex-direction: column; height: 100vh; margin: 0; background: #f9f9f9; }
header { padding: 10px; background: #222; color: #fff; display: flex; justify-content: space-between; align-items: center; }
#dashboard { display: flex; flex: 1; overflow: hidden; }
#activeMessages { flex: 0 0 250px; overflow-y: auto; border-right: 1px solid #ccc; padding: 10px; background: #fff; }
.user-item { padding: 8px; cursor: pointer; border-bottom: 1px solid #eee; border-radius: 4px; margin-bottom: 5px; }
.user-item:hover { background: #f0f0f0; }
.user-item.highlight { background: #ffd27f !important; }
.message-item { font-size: 0.9em; margin-left: 10px; color: #333; }
.read-indicator { font-size: 0.8em; color: #4CAF50; font-weight: bold; margin-left: 5px; }
.unread-indicator { font-size: 0.8em; color: #FF5722; font-weight: bold; margin-left: 5px; }
#main { flex: 1; padding: 10px; }
.status { font-weight: bold; }
.empty-message { font-style: italic; color: #888; }
</style>
</head>
<body>
<header>
  <h2>Agent Dashboard</h2>
  <div>
    Connection: <span id="connectionStatus" class="status">Connecting...</span> | 
    Unread: <span id="unreadCount">0</span>
  </div>
</header>

<div id="dashboard">
  <div id="activeMessages"><div class="empty-message">No active users</div></div>
  <div id="main">Select a user to open chat</div>
</div>

<script>
const agentId = "agent1";
const agentPassword = "agent1";

if (!localStorage.getItem("agentVerified")) window.location.href = "login.html";

const socket = io({ reconnection: true, reconnectionAttempts: Infinity, reconnectionDelay: 1000, reconnectionDelayMax: 5000 });

const connectionStatus = document.getElementById("connectionStatus");

socket.on("connect", () => { 
  connectionStatus.textContent = "Connected"; 
  connectionStatus.style.color = "green"; 
  registerAgent();
});

socket.on("disconnect", () => { 
  connectionStatus.textContent = "Disconnected"; 
  connectionStatus.style.color = "red"; 
});

socket.on("reconnect_attempt", () => { 
  connectionStatus.textContent = "Reconnecting..."; 
  connectionStatus.style.color = "orange"; 
});

function registerAgent() {
  socket.emit("register_permanent_agent", { id: agentId, name: agentId, password: agentPassword });
  loginAgent();
}

function loginAgent() {
  socket.emit("agent_login", { agentId, password: agentPassword, persistent: true });
}

socket.on("agent_login_response", (res) => {
  if(res.success){
    console.log("Agent logged in successfully");
    fetchActiveUsers();
  } else {
    console.error("Agent login failed:", res.message);
  }
});

let allUsers = [];
function fetchActiveUsers() {
  socket.emit("get_existing_users");
}

socket.on("existing_users", (users) => {
  // Get current whatsapp numbers from the server
  const currentWhatsapps = users.map(u => u.whatsapp);
  
  // Clear allUsers and rebuild from server data
  allUsers = users.map(u => ({ whatsapp: u.whatsapp }));
  
  // Clean up unreadMessages - remove entries for users not in current list
  const unreadMessages = JSON.parse(localStorage.getItem("unreadMessages")) || {};
  let cleanedUnreadMessages = {};
  
  // Only keep unread messages for users that are still in the active list
  for (const whatsapp in unreadMessages) {
    if (currentWhatsapps.includes(whatsapp)) {
      cleanedUnreadMessages[whatsapp] = unreadMessages[whatsapp];
    }
  }
  
  // Save cleaned unread messages
  localStorage.setItem("unreadMessages", JSON.stringify(cleanedUnreadMessages));
  
  updateUserList(allUsers);
});

let unreadMessages = JSON.parse(localStorage.getItem("unreadMessages")) || {};
function saveUnreadMessages() {
  localStorage.setItem("unreadMessages", JSON.stringify(unreadMessages));
}

function updateUnreadCount() {
  let count = 0;
  
  // Only count unread messages for users that are currently in allUsers
  const currentWhatsapps = allUsers.map(u => u.whatsapp);
  
  for (const user in unreadMessages) {
    // Only count if user is in current user list
    if (currentWhatsapps.includes(user)) {
      count += Object.keys(unreadMessages[user]).length;
    }
  }
  
  document.getElementById("unreadCount").textContent = count;
}

function updateUserList(users){
  allUsers = users;
  const container = document.getElementById("activeMessages");
  container.innerHTML = "";

  if(users.length === 0){
    const empty = document.createElement("div");
    empty.textContent = "No active users";
    empty.className = "empty-message";
    container.appendChild(empty);
    updateUnreadCount();
    return;
  }

  // Sort users: those with unread messages first
  users.sort((a,b)=>{
    const aUnread = unreadMessages[a.whatsapp] ? Object.keys(unreadMessages[a.whatsapp]).length : 0;
    const bUnread = unreadMessages[b.whatsapp] ? Object.keys(unreadMessages[b.whatsapp]).length : 0;
    return bUnread - aUnread;
  });

  users.forEach(u => {
    const div = document.createElement("div");
    div.className = "user-item";
    
    // Check if this user has any unread messages
    const userUnreadCount = unreadMessages[u.whatsapp] ? Object.keys(unreadMessages[u.whatsapp]).length : 0;
    if(userUnreadCount > 0){
      div.classList.add("highlight");
    }
    
    const title = document.createElement("div");
    title.textContent = u.whatsapp;
    div.appendChild(title);

    if(unreadMessages[u.whatsapp]){
      for(const msgId in unreadMessages[u.whatsapp]){
        const msgDiv = document.createElement("div");
        msgDiv.className = "message-item";
        msgDiv.textContent = unreadMessages[u.whatsapp][msgId];
        div.appendChild(msgDiv);
      }
    }

    div.addEventListener("click", () => {
      window.open(`agent-chat.html?whatsapp=${u.whatsapp}`, "_blank");
      if(unreadMessages[u.whatsapp]){
        delete unreadMessages[u.whatsapp];
        saveUnreadMessages();
      }
      updateUserList(allUsers);
      updateUnreadCount();
    });

    container.appendChild(div);
  });

  updateUnreadCount();
}

function playNotificationSound(){
  try{
    const context = new (window.AudioContext||window.webkitAudioContext)();
    let count = 0;
    const interval = setInterval(()=>{
      const oscillator = context.createOscillator();
      const gainNode = context.createGain();
      oscillator.type = 'sine';
      oscillator.frequency.value = 880;
      gainNode.gain.value = 0.5;
      oscillator.connect(gainNode);
      gainNode.connect(context.destination);
      oscillator.start();
      oscillator.stop(context.currentTime+0.2);
      count++;
      if(count>=15) clearInterval(interval);
    }, 200);
  }catch(e){console.error(e);}
}

function requestNotificationPermission() {
  if("Notification" in window && Notification.permission !== "granted"){
    Notification.requestPermission();
  }
}

function notifyUser(title, body) {
  if("Notification" in window && Notification.permission === "granted"){
    const notification = new Notification(title, { body, icon: "notification.png" });
    notification.onclick = () => window.focus();
  }
}

// ===== REAL-TIME EVENTS =====
socket.on("new_message", handleMessageEvent);
socket.on("message_update", handleMessageEvent);
socket.on("chat_deleted", handleMessageEvent);
socket.on("chat_archived", handleMessageEvent);
socket.on("broadcast_message", handleMessageEvent);

// ===== ADD: HANDLE READ STATUS UPDATES =====
socket.on("messages_read_update", handleMessagesReadUpdate);

function handleMessagesReadUpdate(updateData) {
  const { whatsapp, messageIds } = updateData;
  
  if (whatsapp && messageIds && messageIds.length > 0) {
    // Remove messages that have been marked as read
    if (unreadMessages[whatsapp]) {
      messageIds.forEach(messageId => {
        if (unreadMessages[whatsapp][messageId]) {
          delete unreadMessages[whatsapp][messageId];
        }
      });
      
      // If no more unread messages for this user, remove the user entry
      if (Object.keys(unreadMessages[whatsapp]).length === 0) {
        delete unreadMessages[whatsapp];
      }
      
      saveUnreadMessages();
      updateUnreadCount();
      updateUserList(allUsers);
    }
  }
}

socket.on("new_user", (newUser) => {
  if(newUser && !allUsers.find(u => u.whatsapp === newUser.whatsapp)){
    allUsers.push({ whatsapp: newUser.whatsapp });
    updateUserList(allUsers);
  }
});

// ===== UPDATED: HANDLE MESSAGE WITH READ RECEIPTS CHECK =====
function handleMessageEvent(msg){
  // Check if message should be ignored
  if (shouldIgnoreMessage(msg)) {
    return;
  }
  
  // Only flag messages that are from users AND not marked as read
  if (msg.whatsapp && msg.id && msg.sender === "user" && !msg.read) {
    // Ensure user exists in allUsers
    if(!allUsers.find(u => u.whatsapp === msg.whatsapp)){
      allUsers.push({ whatsapp: msg.whatsapp });
    }

    // Check if message is already marked as read (double-check)
    if (msg.read || (msg.readAt && Date.now() - new Date(msg.readAt).getTime() > 0)) {
      // Message is already read, don't flag it
      if (unreadMessages[msg.whatsapp] && unreadMessages[msg.whatsapp][msg.id]) {
        delete unreadMessages[msg.whatsapp][msg.id];
        
        // If no more unread messages for this user, remove the user entry
        if (Object.keys(unreadMessages[msg.whatsapp]).length === 0) {
          delete unreadMessages[msg.whatsapp];
        }
        
        saveUnreadMessages();
        updateUnreadCount();
        updateUserList(allUsers);
      }
      return;
    }

    if(!unreadMessages[msg.whatsapp]) unreadMessages[msg.whatsapp] = {};
    unreadMessages[msg.whatsapp][msg.id] = msg.text || "New message";
    saveUnreadMessages();
    updateUnreadCount();
    updateUserList(allUsers);
    playNotificationSound();
    notifyUser("New message from " + msg.whatsapp, msg.text || "You have a new message waiting in the dashboard");
  }
}

// ===== NEW FUNCTION: CHECK IF MESSAGE SHOULD BE IGNORED =====
function shouldIgnoreMessage(msg) {
  // Always ignore agent messages
  if (msg.sender === "agent") {
    return true;
  }
  
  // Ignore messages that are already marked as read
  if (msg.read) {
    return true;
  }
  
  // Ignore if there's a readAt timestamp that's in the past
  if (msg.readAt && new Date(msg.readAt).getTime() < Date.now()) {
    return true;
  }
  
  // Additional safety check: ignore if this is an update that makes a message read
  if (msg.eventType === 'read_update') {
    return true;
  }
  
  return false;
}

// ===== ADD: HANDLE CHAT DELETION/ARCHIVAL =====
socket.on("chat_deleted", handleChatRemoval);
socket.on("chat_archived", handleChatRemoval);

function handleChatRemoval(data) {
  const { whatsapp } = data;
  
  if (whatsapp) {
    // Remove user from allUsers list
    allUsers = allUsers.filter(u => u.whatsapp !== whatsapp);
    
    // Remove unread messages for this user
    if (unreadMessages[whatsapp]) {
      delete unreadMessages[whatsapp];
      saveUnreadMessages();
    }
    
    updateUserList(allUsers);
    updateUnreadCount();
  }
}

fetchActiveUsers();

window.addEventListener("DOMContentLoaded", () => {
  requestNotificationPermission();
  updateUserList(allUsers);
  updateUnreadCount();
});
</script>
</body>
</html>