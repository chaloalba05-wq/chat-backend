<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Agent Admin</title>
  <!-- Load display box layout -->
  <link rel="stylesheet" href="display-box.css">
  <!-- Load chat-specific styles -->
  <link rel="stylesheet" href="chat-display.css">
</head>
<body>

<!-- Header with logo -->
<div id="header">
  <div class="logo-text">ALBASTUZ3D</div>
  <div class="logo-subtext">AGENT ADMIN PANEL</div>
</div>

<!-- Main App -->
<div id="app" class="container" style="display: none;">
  
  <!-- Sidebar -->
  <div class="sidebar" id="sidebar">
    <div class="sidebar-header">
      <!-- Agent Info -->
      <div class="agent-info">
        <div class="agent-avatar" id="agentAvatar">A2</div>
        <div class="agent-details">
          <div class="agent-name" id="agentNameDisplay">Agent 2</div>
          <div class="agent-id">ID: <span id="agentIdDisplay">agent2</span></div>
        </div>
      </div>
      
      <!-- Connection Status -->
      <div class="status-container">
        <span class="connection-dot" id="connectionDot"></span>
        <span class="connection-status" id="connectionStatus">Connecting...</span>
        <span id="muteIndicator" class="mute-status unmuted" style="margin-left: auto;">‚ö° Active</span>
      </div>
    </div>
    
    <!-- User List -->
    <div class="user-list-title">Active Conversations</div>
    <div id="userList" class="user-list">
      <div class="empty-state">
        <div class="empty-state-icon">üí¨</div>
        <div class="empty-state-title">No conversations yet</div>
        <div class="empty-state-subtitle">Users will appear here when they send messages</div>
      </div>
    </div>
  </div>
  
  <!-- Chat Detail View (Full Screen) -->
  <div id="chatDetailView" class="chat-detail-view">
    <!-- Chat Header with Back Button -->
    <div class="chat-detail-header">
      <button class="back-button" onclick="exitChat()">‚Üê</button>
      <div class="chat-detail-user-avatar" id="chatDetailUserAvatar">U</div>
      <div class="chat-detail-user-info">
        <div class="chat-detail-user-name" id="currentUser">Select a user</div>
        <div class="chat-detail-user-number" id="whatsappNumber">Click on a user from the left</div>
      </div>
    </div>
    
    <!-- Chat Container -->
    <div class="chat-container">
      <!-- Fixed header section -->
      <header class="chat-header">
        <div class="header-info">
          <h2 id="chatHeaderUser">User Chat</h2>
          <p id="chatHeaderStatus">Status or description</p>
        </div>
      </header>
      
      <!-- Scrollable messages section -->
      <section class="messages-section">
        <!-- Messages container (scrollable area) -->
        <div class="messages-container" id="chatMessages">
          
          <!-- Empty state (shown when no messages) -->
          <div class="empty-state" id="emptyState">
            <p>No messages yet</p>
            <small>Start a conversation</small>
          </div>
          
          <!-- Messages will be dynamically inserted here -->
        </div>
        
        <!-- Scroll to bottom button -->
        <button class="scroll-bottom-btn" id="scrollBottomBtn">‚Üì</button>
      </section>
      
      <!-- Fixed input section at bottom -->
      <section class="input-section">
        <div class="input-wrapper">
          <!-- Text input area -->
          <textarea 
            class="message-input" 
            id="messageInput"
            placeholder="Type your message..." 
            rows="1"
            disabled
          ></textarea>
          
          <!-- Action buttons -->
          <div class="action-buttons">
            <button class="file-attach-btn" type="button" onclick="document.getElementById('fileInput').click()">üìé</button>
            <button class="send-btn" type="button" id="sendButton" onclick="sendMessage()" disabled>Send</button>
          </div>
        </div>
      </section>
      
      <input type="file" id="fileInput" style="display: none;" onchange="handleFileSelect()">
    </div>
  </div>
</div>

<!-- JavaScript -->
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<script src="chat-display.js"></script>
<script>
  // Existing agent JS can remain here
</script>
</body>
</html>
  // ================================================
  // AGENT CONFIGURATION - FIXED VALUES
  // ================================================
  const AGENT_CONFIG = {
    id: "agent2",
    name: "agent2",
    password: "agent2",
    filename: window.location.pathname.split('/').pop() || "agent2.html"
  };
  
  // ================================================
  // SINGLE ROOM SYSTEM CONSTANTS (NO BROADCAST)
  // ================================================
  const ROOM_CONFIG = {
    currentWhatsapp: null,
    userHistoryLoaded: new Map()
  };
  
  let socket = null;
  let currentAgent = null;
  let selectedUser = null;
  let users = new Map();
  let isMuted = false;
  let autoReconnectAttempts = 0;
  const MAX_RECONNECT_ATTEMPTS = 20;
  const RECONNECT_DELAY = 2000;
  let reconnectTimeout = null;
  let selectedFile = null;
  let isMobile = window.innerWidth < 768;
  let isScrolledToBottom = true;
  
  // Track pending messages waiting for server confirmation
  let pendingMessages = new Map(); // Map of tempId to message data
  let socketListenersSetup = false;

  // ================================================
  // PERSISTENT CONNECTION SYSTEM
  // ================================================
  const CONNECTION_CONFIG = {
    heartbeatInterval: 25000,
    heartbeatTimeout: 10000,
    maxReconnectAttempts: 20,
    baseReconnectDelay: 2000,
    maxReconnectDelay: 30000,
    connectionCheckInterval: 5000,
    offlineBuffer: [],
    lastHeartbeat: null,
    heartbeatTimer: null,
    connectionCheckTimer: null,
    isManualDisconnect: false,
    connectionState: 'disconnected',
    pingPongEnabled: true,
    lastActivity: null
  };
  
  function initPersistentConnection() {
    console.log("üîÑ Initializing persistent connection system");
    
    clearTimers();
    
    CONNECTION_CONFIG.connectionState = 'disconnected';
    CONNECTION_CONFIG.isManualDisconnect = false;
    CONNECTION_CONFIG.lastActivity = Date.now();
    
    startConnectionMonitoring();
    
    window.addEventListener('beforeunload', handleBeforeUnload);
    document.addEventListener('visibilitychange', handleVisibilityChange);
    
    console.log("‚úÖ Persistent connection system initialized");
  }
  
  function clearTimers() {
    if (CONNECTION_CONFIG.heartbeatTimer) {
      clearInterval(CONNECTION_CONFIG.heartbeatTimer);
      CONNECTION_CONFIG.heartbeatTimer = null;
    }
    
    if (CONNECTION_CONFIG.connectionCheckTimer) {
      clearInterval(CONNECTION_CONFIG.connectionCheckTimer);
      CONNECTION_CONFIG.connectionCheckTimer = null;
    }
    
    if (reconnectTimeout) {
      clearTimeout(reconnectTimeout);
      reconnectTimeout = null;
    }
  }
  
  function startConnectionMonitoring() {
    CONNECTION_CONFIG.connectionCheckTimer = setInterval(() => {
      checkConnectionHealth();
    }, CONNECTION_CONFIG.connectionCheckInterval);
    
    console.log("üîç Started connection monitoring");
  }
  
  function checkConnectionHealth() {
    if (!socket || !currentAgent) return;
    
    const now = Date.now();
    const lastActivity = CONNECTION_CONFIG.lastActivity || now;
    const timeSinceLastActivity = now - lastActivity;
    
    if (socket.connected && timeSinceLastActivity > 60000) {
      console.log("üîÑ No activity detected, sending keep-alive ping");
      sendHeartbeat();
    }
    
    if (CONNECTION_CONFIG.lastHeartbeat && 
        now - CONNECTION_CONFIG.lastHeartbeat > CONNECTION_CONFIG.heartbeatTimeout + 5000) {
      console.warn("‚ö†Ô∏è Heartbeat response overdue, connection may be stale");
    }
  }
  
  function sendHeartbeat() {
    if (!socket || !socket.connected || !currentAgent) return;
    
    try {
      socket.emit('heartbeat', {
        agentId: currentAgent.id,
        timestamp: Date.now(),
        type: 'ping'
      });
      
      CONNECTION_CONFIG.lastHeartbeat = Date.now();
      console.log("üíì Sent heartbeat");
    } catch (error) {
      console.error("Failed to send heartbeat:", error);
    }
  }
  
  function startHeartbeat() {
    if (CONNECTION_CONFIG.heartbeatTimer) {
      clearInterval(CONNECTION_CONFIG.heartbeatTimer);
    }
    
    CONNECTION_CONFIG.heartbeatTimer = setInterval(() => {
      if (socket && socket.connected && currentAgent) {
        sendHeartbeat();
      }
    }, CONNECTION_CONFIG.heartbeatInterval);
    
    console.log("‚ù§Ô∏è Heartbeat system started");
  }
  
  function updateActivity() {
    CONNECTION_CONFIG.lastActivity = Date.now();
  }
  
  function handleBeforeUnload(event) {
    if (currentAgent && socket && socket.connected) {
      CONNECTION_CONFIG.isManualDisconnect = true;
      
      if (socket && socket.connected) {
        socket.emit('agent_disconnect', {
          agentId: currentAgent.id,
          timestamp: Date.now()
        });
      }
      
      setTimeout(() => {
        if (socket) socket.disconnect();
      }, 100);
    }
  }
  
  function handleVisibilityChange() {
    if (!document.hidden && currentAgent && (!socket || !socket.connected)) {
      console.log("üì± Page became visible, checking connection...");
      
      if (CONNECTION_CONFIG.connectionState === 'disconnected' && 
          !CONNECTION_CONFIG.isManualDisconnect) {
        console.log("üîÑ Attempting reconnection after page visibility restored");
        reconnect();
      }
    }
  }
  
  function reconnect() {
    if (CONNECTION_CONFIG.isManualDisconnect) {
      console.log("Reconnection cancelled - manual disconnect");
      return;
    }
    
    if (autoReconnectAttempts >= CONNECTION_CONFIG.maxReconnectAttempts) {
      console.log("Max reconnection attempts reached");
      updateConnectionStatus('error', 'Max reconnection attempts');
      showNotification('Connection failed after multiple attempts. Please refresh the page.', '#ffebee', '#c62828');
      return;
    }
    
    autoReconnectAttempts++;
    const delay = calculateReconnectDelay();
    
    console.log(`üîÑ Scheduling reconnection attempt ${autoReconnectAttempts} in ${delay}ms`);
    
    updateConnectionStatus('connecting', `Reconnecting (${autoReconnectAttempts}/${CONNECTION_CONFIG.maxReconnectAttempts})`);
    
    if (reconnectTimeout) {
      clearTimeout(reconnectTimeout);
    }
    
    reconnectTimeout = setTimeout(() => {
      console.log("üîÑ Attempting to reconnect...");
      performReconnection();
    }, delay);
  }
  
  function calculateReconnectDelay() {
    const baseDelay = CONNECTION_CONFIG.baseReconnectDelay;
    const maxDelay = CONNECTION_CONFIG.maxReconnectDelay;
    const exponentialDelay = baseDelay * Math.pow(1.5, autoReconnectAttempts - 1);
    const jitter = Math.random() * 1000;
    
    return Math.min(exponentialDelay + jitter, maxDelay);
  }
  
  function performReconnection() {
    CONNECTION_CONFIG.connectionState = 'connecting';
    
    if (socket) {
      socket.removeAllListeners();
      socket.disconnect();
    }
    
    socket = io("https://chat-backend-p2b9.onrender.com", {
      transports: ['websocket', 'polling'],
      reconnection: false,
      timeout: 30000,
      forceNew: true,
      multiplex: false,
      upgrade: true,
      rememberUpgrade: true,
      path: '/socket.io/',
      query: {
        agentId: AGENT_CONFIG.id,
        persistent: 'true',
        reconnectAttempt: autoReconnectAttempts
      }
    });
    
    setupSocketListeners();
    
    const connectionTimeout = setTimeout(() => {
      if (CONNECTION_CONFIG.connectionState === 'connecting') {
        console.log("Connection timeout");
        if (socket) {
          socket.disconnect();
        }
        scheduleReconnect();
      }
    }, 15000);
    
    socket.once('connect', () => {
      clearTimeout(connectionTimeout);
      CONNECTION_CONFIG.connectionState = 'connected';
      autoReconnectAttempts = 0;
      
      console.log("‚úÖ Reconnected to server, Socket ID:", socket.id);
      updateConnectionStatus('connected', 'Reconnected');
      showNotification('Connection restored successfully!', '#e8f5e9', '#2e7d32');
      
      socket.emit('agent_login', { 
        agentId: currentAgent.id, 
        password: AGENT_CONFIG.password,
        reconnect: true
      });
    });
    
    socket.once('connect_error', (error) => {
      clearTimeout(connectionTimeout);
      console.error("Reconnection failed:", error);
      scheduleReconnect();
    });
  }
  
  function updateConnectionStatus(status, message = '') {
    const connectionDot = document.getElementById('connectionDot');
    const connectionStatus = document.getElementById('connectionStatus');
    
    if (!connectionDot || !connectionStatus) return;
    
    connectionDot.className = 'connection-dot';
    
    CONNECTION_CONFIG.connectionState = status;
    
    switch(status) {
      case 'connected':
        connectionDot.classList.add('dot-connected');
        connectionStatus.textContent = message || 'Connected';
        connectionStatus.style.color = "#4CAF50";
        break;
      case 'connecting':
        connectionDot.classList.add('dot-connecting');
        connectionStatus.textContent = message || 'Connecting...';
        connectionStatus.style.color = "#FFC107";
        break;
      case 'disconnected':
        connectionDot.classList.add('dot-disconnected');
        connectionStatus.textContent = message || 'Disconnected';
        connectionStatus.style.color = "#ff9800";
        break;
      case 'error':
        connectionDot.classList.add('dot-error');
        connectionStatus.textContent = message || 'Connection Error';
        connectionStatus.style.color = "#f44336";
        break;
    }
    
    updateActivity();
  }
  
  function scheduleReconnect() {
    reconnect();
  }
  
  // ================================================
  // INITIALIZATION - MODIFIED FOR LOGIN.HTML
  // ================================================
  window.onload = function() {
    const agentData = localStorage.getItem('agentData');
    
    if (!agentData) {
      window.location.href = 'login.html';
      return;
    }
    
    try {
      currentAgent = JSON.parse(agentData);
      
      document.getElementById('agentNameDisplay').textContent = currentAgent.name;
      document.getElementById('agentIdDisplay').textContent = currentAgent.id;
      document.getElementById('agentAvatar').textContent = currentAgent.name.charAt(0).toUpperCase();
      
      document.getElementById('app').style.display = 'flex';
      
      initPersistentConnection();
      initializeSocketConnection();
      
      setupChatUI();
      
    } catch (error) {
      console.error('Error loading agent data:', error);
      localStorage.removeItem('agentData');
      window.location.href = 'login.html';
    }
    
    window.addEventListener('resize', handleResize);
  };
  
  function handleResize() {
    isMobile = window.innerWidth < 768;
  }
  
  // ================================================
  // CHAT UI SETUP
  // ================================================
  function setupChatUI() {
    const textarea = document.getElementById('messageInput');
    const messagesDiv = document.getElementById('chatMessages');
    const scrollBtn = document.getElementById('scrollBottomBtn');
    
    if (textarea) {
      textarea.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = Math.min(this.scrollHeight, 120) + 'px';
      });
      
      textarea.addEventListener('keypress', (e) => {
        updateActivity();
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      });
      
      textarea.addEventListener('focus', updateActivity);
    }
    
    if (messagesDiv && scrollBtn) {
      messagesDiv.addEventListener('scroll', function() {
        const scrollTop = messagesDiv.scrollTop;
        const scrollHeight = messagesDiv.scrollHeight;
        const clientHeight = messagesDiv.clientHeight;
        
        isScrolledToBottom = (scrollHeight - scrollTop - clientHeight) < 50;
        
        if (!isScrolledToBottom) {
          scrollBtn.classList.add('visible');
        } else {
          scrollBtn.classList.remove('visible');
        }
      }, { passive: true });
      
      scrollBtn.addEventListener('click', scrollToBottom);
    }
  }
  
  // ================================================
  // SOCKET SETUP - SINGLE ROOM SYSTEM (NO BROADCAST)
  // ================================================
  function setupSocketListeners() {
    if (socketListenersSetup && socket) {
      socket.removeAllListeners();
      console.log("üîß Removed existing socket listeners");
    }
    
    socket.on('connect', () => {
      console.log("‚úÖ Connected to server, Socket ID:", socket.id);
      updateConnectionStatus('connected');
      autoReconnectAttempts = 0;
      CONNECTION_CONFIG.connectionState = 'connected';
      
      startHeartbeat();
      updateActivity();
      
      if (currentAgent) {
        console.log("üîÑ Authenticating with server...");
        socket.emit('agent_login', { 
          agentId: currentAgent.id, 
          password: AGENT_CONFIG.password,
          reconnect: true
        });
      }
    });
    
    socket.on('agent_login_response', (res) => {
      if (res.success) {
        console.log("‚úÖ Login successful:", res);
        
        currentAgent.name = res.name || currentAgent.name;
        currentAgent.muted = res.muted || false;
        
        isMuted = res.muted || false;
        updateMuteStatus();
        
        document.getElementById('agentNameDisplay').textContent = currentAgent.name;
        document.getElementById('agentIdDisplay').textContent = currentAgent.id;
        document.getElementById('agentAvatar').textContent = currentAgent.name.charAt(0).toUpperCase();
        
        loadAllConversations();
        showNotification('Connected to server successfully!', '#e8f5e9', '#2e7d32');
        
      } else {
        console.error("‚ùå Login failed:", res.message);
        
        localStorage.removeItem('agentData');
        showNotification('Session expired. Please login again.', '#ffebee', '#c62828');
        
        setTimeout(() => {
          window.location.href = 'login.html';
        }, 2000);
      }
      
      updateActivity();
    });
    
    socket.on('connect_error', (error) => {
      console.error("‚ùå Connection error:", error);
      updateConnectionStatus('error', 'Connection error');
      
      if (currentAgent && !CONNECTION_CONFIG.isManualDisconnect) {
        scheduleReconnect();
      }
      
      updateActivity();
    });
    
    socket.on('disconnect', (reason) => {
      console.log("üîå Disconnected:", reason);
      updateConnectionStatus('disconnected');
      CONNECTION_CONFIG.connectionState = 'disconnected';
      
      if (CONNECTION_CONFIG.heartbeatTimer) {
        clearInterval(CONNECTION_CONFIG.heartbeatTimer);
        CONNECTION_CONFIG.heartbeatTimer = null;
      }
      
      if (reason !== 'io client disconnect' && 
          reason !== 'transport close' &&
          currentAgent && 
          !CONNECTION_CONFIG.isManualDisconnect) {
        
        showNotification('Connection lost. Reconnecting...', '#fff3e0', '#f57c00');
        scheduleReconnect();
      }
      
      if (CONNECTION_CONFIG.isManualDisconnect) {
        console.log("Manual disconnect, not reconnecting");
        updateConnectionStatus('disconnected', 'Disconnected by user');
      }
      
      updateActivity();
    });
    
    socket.on('heartbeat_response', (data) => {
      console.log("üíì Heartbeat response received");
      CONNECTION_CONFIG.lastHeartbeat = Date.now();
      updateActivity();
    });
    
    socket.on('pong', () => {
      updateActivity();
    });
    
    // ================================================
    // USER ROOM EVENTS ONLY (NO BROADCAST)
    // ================================================
    socket.on('new_message', (msg) => {
      console.log("üì® USER ROOM message received:", msg);
      updateActivity();
      
      const whatsapp = msg.whatsapp || 'unknown';
      
      // Only process messages with server ID (confirmed messages)
      if (!msg.id) {
        console.log("‚ö†Ô∏è Ignoring message without server ID");
        return;
      }
      
      if (!users.has(whatsapp)) {
        users.set(whatsapp, {
          name: whatsapp,
          lastMsg: msg.text || msg.message || '[Attachment]',
          time: msg.timestamp || new Date().toISOString(),
          messages: []
        });
      }
      
      const user = users.get(whatsapp);
      
      // Check if this is a confirmation of our pending message
      if (msg.tempId && pendingMessages.has(msg.tempId)) {
        console.log("‚úÖ Server confirmed our message with tempId:", msg.tempId);
        pendingMessages.delete(msg.tempId);
      }
      
      // Check if message already exists to prevent duplicates
      const existingIndex = user.messages.findIndex(m => 
        (m.id && m.id === msg.id) || 
        (m.text === (msg.text || msg.message) && 
         m.time === msg.timestamp)
      );
      
      if (existingIndex === -1) {
        user.messages.push({
          text: msg.text || msg.message,
          time: msg.timestamp || new Date().toISOString(),
          sender: msg.sender || 'unknown',
          attachment: msg.attachment,
          agentId: msg.agentId,
          agentName: msg.agentName,
          id: msg.id
        });
        
        user.lastMsg = msg.text || msg.message || '[Attachment]';
        user.time = msg.timestamp || new Date().toISOString();
      }
      
      updateUserList();
      
      if (selectedUser === whatsapp) {
        showMessages();
      }
    });
    
    socket.on('message_confirmation', (data) => {
      console.log("‚úÖ Message confirmed by server:", data);
      updateActivity();
      
      if (data.tempId && data.serverId) {
        // Store the mapping for future reference
        pendingMessages.set(data.tempId, {
          serverId: data.serverId,
          timestamp: data.timestamp
        });
        
        // The actual message will come through new_message event
        // We just need to remove the pending indicator if it exists
      }
    });
    
    socket.on('user_chat_history', (data) => {
      console.log("üìú USER CHAT HISTORY received:", data);
      updateActivity();
      
      if (data.whatsapp && data.messages) {
        const user = users.get(data.whatsapp);
        if (user) {
          // Clear existing messages for this user
          user.messages = [];
          
          // Add historical messages (only confirmed ones with IDs)
          data.messages.forEach(msg => {
            if (msg.id) { // Only add messages with server IDs
              user.messages.push({
                text: msg.text || msg.message,
                time: msg.timestamp || msg.time,
                sender: msg.sender || 'unknown',
                attachment: msg.attachment,
                agentId: msg.agentId,
                agentName: msg.agentName,
                id: msg.id
              });
            }
          });
          
          ROOM_CONFIG.userHistoryLoaded.set(data.whatsapp, true);
          
          if (selectedUser === data.whatsapp) {
            showMessages();
          }
        }
      }
    });
    
    socket.on('user_room_joined', (data) => {
      console.log("‚úÖ Joined user room:", data.whatsapp);
      updateActivity();
      
      ROOM_CONFIG.currentWhatsapp = data.whatsapp;
      
      if (data.history) {
        console.log("üìú Received user room history");
        const user = users.get(data.whatsapp);
        if (user) {
          // Only add confirmed messages with IDs
          user.messages = data.history.filter(msg => msg.id);
          
          if (selectedUser === data.whatsapp) {
            showMessages();
          }
        }
      }
    });
    
    socket.on('user_message_update', (data) => {
      console.log("üìù User message update:", data);
      updateActivity();
      
      if (data.whatsapp && users.has(data.whatsapp)) {
        const user = users.get(data.whatsapp);
        if (data.type === 'typing' && data.typing) {
          showTypingIndicator(data.whatsapp);
        }
      }
    });
    
    socket.on('forwarded_message', (data) => {
      updateActivity();
      if (data.type === 'user_message' && data.data && data.data.id) {
        const whatsapp = data.data.whatsapp || data.data.userId || 'User';
        addUserMessage(whatsapp, data.data.message, data.data);
      }
    });
    
    socket.on('message_deleted', (data) => {
      console.log("üóëÔ∏è Message deleted:", data);
      updateActivity();
      if (data.whatsapp && users.has(data.whatsapp)) {
        const user = users.get(data.whatsapp);
        const index = user.messages.findIndex(m => m.id === data.messageId);
        if (index > -1) {
          user.messages.splice(index, 1);
        }
      }
      
      if (selectedUser === data.whatsapp) {
        showMessages();
      }
    });
    
    socket.on('chat_deleted', (data) => {
      console.log("üóëÔ∏è Chat deleted:", data.whatsapp);
      updateActivity();
      if (users.has(data.whatsapp)) {
        users.delete(data.whatsapp);
      }
      updateUserList();
      
      if (selectedUser === data.whatsapp) {
        exitChat();
      }
    });
    
    socket.on('mute_status', (data) => {
      updateActivity();
      if (data.agentId === currentAgent.id) {
        isMuted = data.muted;
        updateMuteStatus();
        
        showNotification(
          isMuted ? 'üîá Account muted by Super Admin' : 'üîä Account unmuted by Super Admin',
          isMuted ? '#ffcdd2' : '#c8e6c9',
          isMuted ? '#c62828' : '#2e7d32'
        );
      }
    });
    
    socket.on('message_history', (messages) => {
      updateActivity();
      if (selectedUser && messages) {
        const user = users.get(selectedUser);
        if (user) {
          // Only add confirmed messages with IDs
          user.messages = messages.filter(msg => msg.id);
          showMessages();
        }
      }
    });
    
    socket.on('connection_stable', () => {
      console.log("‚úÖ Connection is stable");
      updateConnectionStatus('connected', 'Stable connection');
      updateActivity();
    });
    
    socketListenersSetup = true;
  }
  
  // ================================================
  // SOCKET INITIALIZATION FUNCTION
  // ================================================
  function initializeSocketConnection() {
    console.log("üîÑ Initializing socket connection...");
    
    updateConnectionStatus('connecting');
    
    socket = io("https://chat-backend-p2b9.onrender.com", {
      transports: ['websocket', 'polling'],
      reconnection: false,
      timeout: 30000,
      forceNew: true,
      multiplex: false,
      upgrade: true,
      rememberUpgrade: true,
      path: '/socket.io/',
      query: {
        agentId: currentAgent.id,
        persistent: 'true',
        fromMainApp: 'true'
      }
    });
    
    setupSocketListeners();
  }
  
  // ================================================
  // USER MANAGEMENT
  // ================================================
  function loadAllConversations() {
    if (!socket || !socket.connected) return;
    
    console.log("üìã Loading all conversations...");
    updateActivity();
    
    socket.emit('get_existing_users');
    
    socket.once('existing_users', (usersList) => {
      console.log("üìã Loaded existing users:", usersList.length);
      updateActivity();
      
      users.clear();
      pendingMessages.clear();
      
      usersList.forEach(user => {
        if (user.whatsapp) {
          users.set(user.whatsapp, {
            name: user.whatsapp,
            lastMsg: user.lastMessage || 'No messages yet',
            time: user.lastMessageTime || new Date().toISOString(),
            messages: [],
            historyLoaded: false
          });
        }
      });
      
      updateUserList();
    });
  }
  
  function addUserMessage(userId, message, data) {
    updateActivity();
    if (!data.id) {
      console.log("‚ö†Ô∏è Ignoring message without server ID");
      return;
    }
    
    if (!users.has(userId)) {
      users.set(userId, {
        name: userId,
        lastMsg: message || '[Attachment]',
        time: data.timestamp || new Date().toISOString(),
        messages: [],
        historyLoaded: false
      });
    }
    
    const user = users.get(userId);
    
    const isDuplicate = user.messages.some(msg => 
      msg.id === data.id || 
      (msg.text === message && msg.time === (data.timestamp || new Date().toISOString()))
    );
    
    if (!isDuplicate) {
      user.messages.push({
        text: message,
        time: data.timestamp || new Date().toISOString(),
        sender: data.sender || 'user',
        attachment: data.attachment,
        id: data.id
      });
      user.lastMsg = message || '[Attachment]';
      user.time = data.timestamp || new Date().toISOString();
    }
    
    updateUserList();
    
    if (selectedUser === userId) {
      showMessages();
    }
  }
  
  function updateUserList() {
    const userList = document.getElementById('userList');
    updateActivity();
    
    const sortedUsers = Array.from(users.entries())
      .sort((a, b) => new Date(b[1].time) - new Date(a[1].time));
    
    userList.innerHTML = '';
    
    if (sortedUsers.length === 0) {
      userList.innerHTML = `
        <div class="empty-state">
          <div class="empty-state-icon">üí¨</div>
          <div class="empty-state-title">No conversations yet</div>
          <div class="empty-state-subtitle">Users will appear here when they send messages</div>
        </div>
      `;
      return;
    }
    
    sortedUsers.forEach(([userId, user]) => {
      const div = document.createElement('div');
      div.className = `user-item ${selectedUser === userId ? 'active' : ''}`;
      div.onclick = () => {
        selectUser(userId);
      };
      
      const time = formatTime(user.time);
      const userInitial = userId.charAt(0).toUpperCase();
      const preview = user.lastMsg.length > 50 ? user.lastMsg.substring(0, 50) + '...' : user.lastMsg;
      
      div.innerHTML = `
        <div class="user-avatar">${userInitial}</div>
        <div class="user-content">
          <div class="user-name-row">
            <div class="user-name">${user.name}</div>
            <div class="user-time">${time}</div>
          </div>
          <div class="user-preview">${preview}</div>
        </div>
      `;
      
      userList.appendChild(div);
    });
  }
  
  // ================================================
  // CHAT FUNCTIONS - UPDATED FOR CONFIRMED MESSAGES ONLY
  // ================================================
  function selectUser(userId) {
    selectedUser = userId;
    const user = users.get(userId);
    updateActivity();
    
    document.getElementById('currentUser').textContent = user.name;
    document.getElementById('whatsappNumber').textContent = `WhatsApp: ${userId}`;
    document.getElementById('chatDetailUserAvatar').textContent = userId.charAt(0).toUpperCase();
    document.getElementById('chatHeaderUser').textContent = user.name;
    document.getElementById('chatHeaderStatus').textContent = `WhatsApp: ${userId}`;
    
    const messageInput = document.getElementById('messageInput');
    const sendBtn = document.getElementById('sendButton');
    
    if (!isMuted) {
      if (messageInput) messageInput.disabled = false;
      if (sendBtn) sendBtn.disabled = false;
      if (messageInput) {
        messageInput.placeholder = "Type your message...";
        messageInput.focus();
      }
      
      if (socket && socket.connected) {
        console.log(`üö™ Joining user room: ${userId}`);
        socket.emit('join_user_room', {
          whatsapp: userId,
          agentId: currentAgent.id,
          agentName: currentAgent.name
        });
        
        socket.emit('get_messages', { 
          whatsapp: userId, 
          agentId: currentAgent.id,
          markAsRead: true 
        });
      }
    }
    
    showMessages();
    
    document.getElementById('chatDetailView').classList.add('active');
    
    updateActivity();
  }
  
  function exitChat() {
    selectedUser = null;
    ROOM_CONFIG.currentWhatsapp = null;
    
    document.getElementById('chatDetailView').classList.remove('active');
    
    updateUserList();
    updateActivity();
  }
  
  function showMessages() {
    if (!selectedUser) return;
    updateActivity();
    
    const messagesDiv = document.getElementById('chatMessages');
    const emptyState = document.getElementById('emptyState');
    const user = users.get(selectedUser);
    
    if (!messagesDiv || !user) return;
    
    if (emptyState) {
      emptyState.style.display = 'none';
    }
    
    const existingMessages = messagesDiv.querySelectorAll('.message-bubble, .typing-indicator, .upload-preview, .date-separator');
    existingMessages.forEach(el => el.remove());
    
    // Filter to show only confirmed messages (with IDs)
    const confirmedMessages = user.messages.filter(msg => msg.id);
    
    if (confirmedMessages.length === 0) {
      if (emptyState) {
        emptyState.style.display = 'flex';
      }
      scrollToBottom();
      return;
    }
    
    // Remove duplicates
    const uniqueMessages = [];
    const seenMessages = new Set();
    
    confirmedMessages.forEach(msg => {
      const messageKey = `${msg.id || ''}-${msg.text || ''}-${msg.time}-${msg.sender}`;
      if (!seenMessages.has(messageKey)) {
        seenMessages.add(messageKey);
        uniqueMessages.push(msg);
      }
    });
    
    user.messages = uniqueMessages;
    
    const groupedMessages = groupMessagesByDate(user.messages);
    
    Object.keys(groupedMessages).forEach(date => {
      if (Object.keys(groupedMessages).length > 1) {
        const dateDiv = document.createElement('div');
        dateDiv.className = 'date-separator';
        dateDiv.innerHTML = `<span>${formatDate(date)}</span>`;
        messagesDiv.appendChild(dateDiv);
      }
      
      groupedMessages[date].forEach(msg => {
        const messageElement = createMessageElement(msg);
        messagesDiv.appendChild(messageElement);
      });
    });
    
    setTimeout(() => {
      scrollToBottom();
    }, 50);
  }
  
  function createMessageElement(msg) {
    const messageDiv = document.createElement("div");
    const isAgent = msg.sender === 'agent' || msg.sender === 'admin' || msg.agentId === currentAgent.id;
    
    messageDiv.className = "message-bubble " + (isAgent ? "agent-message" : "user-message");
    
    // Messages are only displayed if they have an ID (confirmed by server)
    const hasServerId = !!msg.id;
    
    let content = "";
    if (msg.attachment) {
      content = formatAttachment(msg.attachment);
    }
    
    const senderName = isAgent 
      ? (msg.agentName || currentAgent?.name || 'Agent') 
      : 'User';
    
    // Always show actual time for confirmed messages
    const timeText = formatTime(msg.time);
    const timeTitle = formatDateTime(msg.time);
    
    messageDiv.innerHTML = `
      <div class="message-meta">
        <span class="message-sender">
          ${senderName}
        </span>
        <span class="message-time" title="${timeTitle}">
          ${timeText}
        </span>
      </div>
      <div class="message-content">${msg.text || msg.message || ''}</div>
      ${content}
    `;
    
    // Add data attributes for tracking
    if (msg.id) {
      messageDiv.dataset.messageId = msg.id;
    }
    
    return messageDiv;
  }
  
  function formatAttachment(attachment) {
    if (!attachment) return '';
    
    const fileType = attachment.mimetype?.split('/')[0] || 'file';
    let icon = 'üìÑ';
    let preview = '';
    
    const fileUrl = attachment.url || attachment.path;
    const fileName = attachment.originalname || attachment.filename || 'file';
    const fileSize = attachment.size ? formatFileSize(attachment.size) : '';
    
    if (fileType === 'image') {
      icon = 'üñºÔ∏è';
      preview = `<img src="${fileUrl}" alt="${fileName}" loading="lazy" style="max-width: 100%; border-radius: 8px; margin-top: 8px;">`;
    } else if (fileType === 'video') {
      icon = 'üé¨';
      preview = `<div style="margin-top: 8px;"><video src="${fileUrl}" controls preload="metadata" style="max-width: 100%; border-radius: 8px;"></video></div>`;
    } else if (fileType === 'audio') {
      icon = 'üéµ';
      preview = `<div style="margin-top: 8px;"><audio src="${fileUrl}" controls preload="metadata" style="width: 100%;"></audio></div>`;
    } else if (attachment.mimetype?.includes('pdf')) {
      icon = 'üìï';
    }
    
    return `
      <div class="attachment" style="margin-top: 8px;">
        <a href="${fileUrl}" target="_blank" download="${fileName}" style="display: inline-flex; align-items: center; color: #667eea; text-decoration: none;">
          ${icon} ${fileName}
          ${fileSize ? `<span style="color: #666; font-size: 0.9em; margin-left: 8px;">(${fileSize})</span>` : ''}
        </a>
        ${preview}
      </div>
    `;
  }
  
  function formatFileSize(bytes) {
    if (!bytes || bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }
  
  function groupMessagesByDate(messages) {
    const grouped = {};
    
    messages.forEach(msg => {
      const date = new Date(msg.time).toDateString();
      if (!grouped[date]) {
        grouped[date] = [];
      }
      grouped[date].push(msg);
    });
    
    return grouped;
  }
  
  function showTypingIndicator(whatsapp) {
    if (selectedUser !== whatsapp) return;
    
    const messagesDiv = document.getElementById('chatMessages');
    const existingIndicator = messagesDiv.querySelector('.typing-indicator');
    
    if (existingIndicator) {
      existingIndicator.remove();
    }
    
    const typingDiv = document.createElement('div');
    typingDiv.className = 'typing-indicator';
    typingDiv.innerHTML = `
      <div class="typing-dot"></div>
      <div class="typing-dot"></div>
      <div class="typing-dot"></div>
    `;
    
    messagesDiv.appendChild(typingDiv);
    scrollToBottom();
    
    setTimeout(() => {
      if (typingDiv.parentNode) {
        typingDiv.remove();
      }
    }, 3000);
  }
  
  // ================================================
  // FILE HANDLING
  // ================================================
  function handleFileSelect() {
    const fileInput = document.getElementById('fileInput');
    
    if (fileInput && fileInput.files.length > 0) {
      selectedFile = fileInput.files[0];
      
      const messagesDiv = document.getElementById('chatMessages');
      if (messagesDiv) {
        const existingPreview = messagesDiv.querySelector('.upload-preview');
        if (existingPreview) {
          existingPreview.remove();
        }
        
        const previewDiv = document.createElement('div');
        previewDiv.className = 'upload-preview';
        previewDiv.innerHTML = `
          <span>${selectedFile.name}</span>
          <div class="progress-bar" style="width: 0%;"></div>
        `;
        messagesDiv.appendChild(previewDiv);
        scrollToBottom();
      }
      
      uploadFile(function(fileInfo) {
        if (fileInfo) {
          sendMessageToServer('', fileInfo);
        }
        
        const preview = messagesDiv?.querySelector('.upload-preview');
        if (preview) {
          preview.remove();
        }
      });
    } else {
      selectedFile = null;
    }
    updateActivity();
  }
  
  function uploadFile(callback) {
    if (!selectedFile) {
      if (callback) callback(null);
      return;
    }
    
    const formData = new FormData();
    formData.append('file', selectedFile);
    
    const xhr = new XMLHttpRequest();
    
    xhr.upload.addEventListener('progress', function(e) {
      if (e.lengthComputable) {
        const percentComplete = (e.loaded / e.total) * 100;
        const progressBar = document.querySelector('.upload-preview .progress-bar');
        if (progressBar) {
          progressBar.style.width = percentComplete + '%';
        }
      }
    });
    
    xhr.addEventListener('load', function() {
      if (xhr.status === 200) {
        try {
          const response = JSON.parse(xhr.responseText);
          if (response.success && callback) {
            callback(response.file);
          } else {
            alert('Upload failed: ' + (response.message || 'Unknown error'));
            if (callback) callback(null);
          }
        } catch (e) {
          alert('Upload failed: Invalid response from server');
          if (callback) callback(null);
        }
      } else {
        alert('Upload failed with status: ' + xhr.status);
        if (callback) callback(null);
      }
      
      const fileInput = document.getElementById('fileInput');
      if (fileInput) fileInput.value = '';
      selectedFile = null;
    });
    
    xhr.addEventListener('error', function() {
      alert('Upload failed. Please check your connection.');
      if (callback) callback(null);
    });
    
    xhr.open('POST', '/upload');
    xhr.send(formData);
  }
  
  // ================================================
  // MESSAGE SENDING - WAIT FOR SERVER CONFIRMATION
  // ================================================
  function sendMessage() {
    if (isMuted) {
      alert("Your account is muted by Super Admin. You cannot send messages.");
      updateActivity();
      return;
    }
    
    if (!socket || !socket.connected) {
      alert("Not connected to server. Please wait for reconnection.");
      updateActivity();
      return;
    }
    
    const input = document.getElementById('messageInput');
    const text = input ? input.value.trim() : '';
    
    if (!text && !selectedFile) {
      alert("Please enter a message or select a file");
      return;
    }
    
    updateActivity();
    
    if (selectedFile) {
      return;
    } else {
      // Clear input immediately (message will appear when confirmed)
      if (input) {
        input.value = "";
        input.style.height = 'auto';
        input.style.height = '50px';
      }
      
      // Send to server - message will appear when we get confirmation
      sendMessageToServer(text);
    }
  }
  
  function sendMessageToServer(text, fileInfo = null) {
    if (!selectedUser) return;
    
    // Create temporary ID for tracking
    const tempId = 'temp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    
    const messageData = {
      whatsapp: selectedUser,
      message: text,
      agentId: currentAgent.id,
      agentName: currentAgent.name,
      sender: 'agent',
      tempId: tempId,
      timestamp: new Date().toISOString()
    };
    
    if (fileInfo) {
      messageData.attachment = fileInfo;
    }
    
    // Store as pending - won't be displayed until confirmed
    pendingMessages.set(tempId, {
      text: text,
      fileInfo: fileInfo,
      timestamp: messageData.timestamp
    });
    
    // Send to server
    socket.emit('agent_message', messageData);
    
    // Also emit to user room directly
    socket.emit('send_message', {
      whatsapp: selectedUser,
      sender: 'agent',
      text: text,
      agentId: currentAgent.id,
      agentName: currentAgent.name,
      attachment: fileInfo,
      tempId: tempId,
      timestamp: messageData.timestamp
    });
  }
  
  function showError(message) {
    showNotification(message, '#ffebee', '#c62828');
  }
  
  // ================================================
  // UTILITY FUNCTIONS
  // ================================================
  function updateMuteStatus() {
    const muteIndicator = document.getElementById('muteIndicator');
    const sendBtn = document.getElementById('sendButton');
    const messageInput = document.getElementById('messageInput');
    
    if (isMuted) {
      if (muteIndicator) {
        muteIndicator.textContent = "üîá Muted";
        muteIndicator.className = "mute-status muted";
      }
      if (sendBtn) sendBtn.disabled = true;
      if (messageInput) {
        messageInput.disabled = true;
        messageInput.placeholder = "Account is muted by Super Admin";
      }
    } else {
      if (muteIndicator) {
        muteIndicator.textContent = "‚ö° Active";
        muteIndicator.className = "mute-status unmuted";
      }
      if (sendBtn && selectedUser) sendBtn.disabled = false;
      if (messageInput && selectedUser) {
        messageInput.disabled = false;
        messageInput.placeholder = "Type your message...";
      }
    }
    
    updateActivity();
  }
  
  function showNotification(message, bgColor, textColor) {
    const notification = document.createElement('div');
    notification.className = 'notification';
    notification.style.cssText = `
      background: ${bgColor}; 
      color: ${textColor}; 
      border: 1px solid ${textColor}33;
    `;
    notification.innerHTML = message;
    document.body.appendChild(notification);
    setTimeout(() => notification.remove(), 3000);
    updateActivity();
  }
  
  function formatTime(timestamp) {
    const date = new Date(timestamp);
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }
  
  function formatDateTime(timestamp) {
    const date = new Date(timestamp);
    return date.toLocaleString([], { 
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  }
  
  function formatDate(dateString) {
    const date = new Date(dateString);
    const today = new Date();
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    
    if (date.toDateString() === today.toDateString()) {
      return 'Today';
    } else if (date.toDateString() === yesterday.toDateString()) {
      return 'Yesterday';
    } else {
      return date.toLocaleDateString([], { weekday: 'long', month: 'short', day: 'numeric' });
    }
  }
  
  function scrollToBottom() {
    const messagesDiv = document.getElementById("chatMessages");
    if (messagesDiv) {
      requestAnimationFrame(() => {
        messagesDiv.scrollTo({
          top: messagesDiv.scrollHeight,
          behavior: 'smooth'
        });
      });
      isScrolledToBottom = true;
      const scrollBtn = document.getElementById("scrollBottomBtn");
      if (scrollBtn) {
        scrollBtn.classList.remove('visible');
      }
    }
  }
  
  // ================================================
  // EVENT LISTENERS
  // ================================================
  window.addEventListener('popstate', function() {
    updateActivity();
    if (selectedUser) {
      exitChat();
    }
  });
  
  document.addEventListener('touchmove', function(e) {
    if (e.scale !== 1) { e.preventDefault(); }
  }, { passive: false });
</script>
</body>
</html>